<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/weekOfYear.js"></script>

    <style>
        body { font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; margin: 20px; background: #f4f6f8; }
        .card { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        h2 { margin-top: 0; color: #2c3e50; border-left: 5px solid #3498db; padding-left: 10px; }
        #chart { width: 100%; height: 900px; }
        .status { margin-bottom: 15px; color: #7f8c8d; font-size: 0.95em; font-family: monospace; }
        .badge { background: #28a745; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 10px;}
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 10px;
        }
        .controls > * {
            flex-shrink: 0;
        }
        .btn {
            background: #e9ecef;
            border: 1px solid #ced4da;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            margin-right: 8px;
            transition: background 0.2s, color 0.2s;
        }
        .btn:hover { background: #d3d9df; }
        .btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        .indicator-checkbox {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 0.95em;
            user-select: none;
        }
        .indicator-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 6px;
            cursor: pointer;
        }
        .config-dropdown-label {
            display: inline-flex;
            align-items: center;
            margin-left: 20px;
            font-size: 0.95em;
            color: #2c3e50;
            font-weight: 500;
            white-space: nowrap;
        }
        .config-dropdown {
            margin-left: 8px;
            padding: 6px 12px;
            border: 2px solid #3498db;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            outline: none;
        }
        .config-dropdown:hover {
            border-color: #2980b9;
            background: #f8f9fa;
        }
        .config-dropdown:focus {
            border-color: #2980b9;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        .config-notes {
            display: inline-block;
            margin-left: 15px;
            padding: 12px 16px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            font-size: 0.9em;
            color: #856404;
            min-width: 400px;
            max-width: 700px;
            max-height: 200px;
            line-height: 1.6;
            vertical-align: top;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
            white-space: normal;
        }
        .config-notes h4 {
            margin: 0 0 8px 0;
            font-size: 1em;
            color: #856404;
            font-weight: 600;
        }
        .config-notes ol {
            margin: 0;
            padding-left: 20px;
        }
        .config-notes li {
            margin: 5px 0;
            font-size: 1em;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.5;
        }
        .config-notes.hidden {
            display: none;
        }
        .config-notes::-webkit-scrollbar {
            width: 8px;
        }
        .config-notes::-webkit-scrollbar-track {
            background: #f0e5c9;
            border-radius: 3px;
        }
        .config-notes::-webkit-scrollbar-thumb {
            background: #ffc107;
            border-radius: 3px;
        }
        .config-notes::-webkit-scrollbar-thumb:hover {
            background: #e0a800;
        }
        .floating-panel {
            position: fixed;
            top: 50%;
            right: -320px;
            transform: translateY(-50%);
            width: 320px;
            background: white;
            border-radius: 12px 0 0 12px;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            transition: right 0.3s ease;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
        }
        .floating-panel.open {
            right: 0;
            display: block;
        }
        .panel-toggle {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            background: #3498db;
            color: white;
            border: none;
            width: 40px;
            height: 60px;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            font-size: 20px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
        }
        .panel-toggle:hover {
            background: #2980b9;
        }
        .panel-content {
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .panel-section {
            margin-bottom: 5px;
            /*padding-bottom: 0px;*/
            border-bottom: 1px solid #eee;
            transition: all 0.3s ease;
        }
        .panel-section:last-child {
            border-bottom: none;
        }
        .panel-section.hidden {
            display: none;
        }
        .panel-section h3 {
            margin: 0 0 12px 0;
            font-size: 1em;
            color: #2c3e50;
        }
        .range-input {
            margin-bottom: 5px;
        }
        .range-input label {
            display: block;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 8px;
        }
        .range-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .range-slider-container {
            flex: 1;
            min-width: 0;
        }
        .range-slider-wrapper {
            position: relative;
            padding: 0 5px;
        }
        .range-slider-container input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        .range-slider-container input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            border-radius: 10px;
            background: #d0d0d0;
        }
        .range-slider-container input[type="range"]::-moz-range-track {
            width: 100%;
            height: 8px;
            border-radius: 10px;
            background: #d0d0d0;
        }
        .range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #17a2b8;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.2s;
            margin-top: -6px;
        }
        .range-slider-container input[type="range"]::-webkit-slider-thumb:hover {
            background: #138496;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        .range-slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #17a2b8;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .range-slider-container input[type="range"]::-moz-range-thumb:hover {
            background: #138496;
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        .range-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 5px;
        }
        .range-labels span {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
        }
        .range-control input[type="number"] {
            width: 70px;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
            transition: border-color 0.2s;
        }
        .range-control input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }
        .range-value-display {
            min-width: 45px;
            text-align: center;
            font-weight: bold;
            color: #3498db;
            font-size: 1em;
        }
        .zone-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 0.9em;
        }
        .zone-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
        }
        .zone-checkbox label:not(.toggle-switch) {
            cursor: pointer;
            user-select: none;
        }
        .zone-checkbox input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.4;
        }
        .zone-checkbox:has(input:disabled) {
            opacity: 0.5;
            color: #999;
        }
        .master-toggle {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            font-size: 0.95em;
            font-weight: bold;
            transition: background 0.2s;
        }
        .master-toggle:hover {
            background: #c0392b;
        }
        .master-toggle.active {
            background: #27ae60;
        }
        .master-toggle.active:hover {
            background: #229954;
        }

        /* è† å›Šç‹€é–‹é—œæ¨£å¼ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
            margin-right: 10px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 26px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #27ae60;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        .toggle-switch input:disabled + .toggle-slider {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .toggle-switch input:disabled + .toggle-slider:before {
            background-color: #e0e0e0;
        }

        .panel-control-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            margin-left: 15px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .panel-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }
        .panel-control-btn:active {
            transform: translateY(0);
        }
        .panel-control-btn.panel-open {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* é™„è‘—åœ¨æ§åˆ¶é¢æ¿æ—çš„æ›¸ç±¤å´é‚Šæ¬„ */
        .sidebar {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            background: #2c3e50;
            border-radius: 12px 0 0 12px;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            z-index: 1001;
            transition: right 0.3s ease, width 0.3s ease;
        }
        .sidebar.panel-open {
            right: 320px;
        }
        .sidebar:hover {
            width: 150px;
        }
        .sidebar-bookmark {
            position: relative;
            padding: 15px;
            cursor: pointer;
            color: white;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
        }
        .sidebar-bookmark:last-child {
            border-bottom: none;
        }
        .sidebar-bookmark:hover {
            background: rgba(52, 152, 219, 0.3);
        }
        .sidebar-bookmark.active {
            background: #3498db;
        }
        .sidebar-bookmark-icon {
            min-width: 20px;
            font-size: 18px;
            margin-right: 10px;
            display: inline-block;
        }
        .sidebar-bookmark-text {
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .sidebar:hover .sidebar-bookmark-text {
            opacity: 1;
        }
    </style>
</head>
<body>

<!-- å³å´æ›¸ç±¤å´é‚Šæ¬„ -->
<div class="sidebar">
    <div class="sidebar-bookmark" id="macdReversalBookmark">
        <span class="sidebar-bookmark-icon">ğŸ”„</span>
        <span class="sidebar-bookmark-text">MACDåè½‰</span>
    </div>
    <div class="sidebar-bookmark" id="highPriceAreaBookmark">
        <span class="sidebar-bookmark-icon">ğŸ“ˆ</span>
        <span class="sidebar-bookmark-text">é«˜æª”å€åŸŸ</span>
    </div>
    <div class="sidebar-bookmark" id="lowPriceAreaBookmark">
        <span class="sidebar-bookmark-icon">ğŸ“Š</span>
        <span class="sidebar-bookmark-text">ä½æª”å€åŸŸ</span>
    </div>
</div>

<div class="card">
    <h2 id="chart-title">ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ) <span class="badge">Real Data</span></h2>
    <div class="controls">
        <button class="btn active" data-period="daily">æ—¥ç·š</button>
        <button class="btn" data-period="weekly">å‘¨ç·š</button>
        <button class="btn" data-period="bi-weekly">é›™å‘¨ç·š</button>
        <button class="btn" data-period="tri-weekly">ä¸‰å‘¨ç·š</button>
        <button class="btn" data-period="monthly">æœˆç·š</button>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="macd" checked> MACD
        </label>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="kd" checked> KD
        </label>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="rsi" checked> RSI
        </label>
        <button id="clearCrosshairBtn" class="btn">æ¸…ç©ºåå­—ç·š</button>
        <label class="config-dropdown-label">
            æ¨è–¦é…ç½®ï¼š
            <select id="configDropdown" class="config-dropdown">
                <option value="">-- è«‹é¸æ“‡é…ç½® --</option>
                <option value="easyMonthly">è¼•é¬†æœˆæ”¾</option>
            </select>
        </label>
        <div id="configNotes" class="config-notes hidden">
            <h4>ğŸ“‹ ä½¿ç”¨æ³¨æ„äº‹é …</h4>
            <ol id="configNotesList"></ol>
        </div>
    </div>
    <div class="status" id="status">ç³»çµ±ç‹€æ…‹ï¼šåˆå§‹åŒ–...</div>
    <div id="chart"></div>
</div>

<!-- MACDåè½‰æµ®å‹•æ§åˆ¶é¢æ¿ -->
<div class="floating-panel" id="macdReversalPanel">
    <button class="panel-toggle" id="macdReversalPanelToggle">âš™ï¸</button>
    <div class="panel-content">

        <div class="panel-section">
            <h3>ğŸ”„ MACDåè½‰æ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="macdBuySellMasterToggle">
                    <span class="toggle-slider"></span>
                </label>
                <label for="macdBuySellMasterToggle" style="font-size: 1em; font-weight: 500;">é¡¯ç¤ºæ‰€æœ‰åè½‰æ¨™è¨˜</label>
            </div>
        </div>

        <div class="panel-section">
            <h3>ğŸ”´ MACDé«˜é»é–¥å€¼æ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="macdSellToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="macdSellToggle">é¡¯ç¤ºé«˜é»æ¨™è¨˜ï¼ˆæ·±ç´…è‰²ï¼‰</label>
            </div>
            <div class="range-input">
                <label>é«˜é»é–¾å€¼ï¼ˆD-Mæ­£å€¼åè½‰å¾Œé«˜æ–¼æ­¤å€¼ï¼‰:</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="macdSellThresholdRange" min="-1500" max="1500" step="5" value="0">
                        </div>
                        <div class="range-labels">
                            <span>-1500</span>
                            <span>1500</span>
                        </div>
                    </div>
                    <input type="number" id="macdSellThreshold" min="-1500" max="1500" step="5" value="0">
                </div>
            </div>
            <p style="font-size: 0.85em; color: #666; margin: 8px 0 0 0; line-height: 1.4;">
                ç•¶ MACD D-M å¾æ­£å€¼å€å‘ä¸‹åè½‰ï¼Œä¸”åè½‰å¾Œçš„å€¼é«˜æ–¼é–¾å€¼æ™‚æ¨™è¨˜
            </p>
        </div>

        <div class="panel-section">
            <h3>ğŸŸ¢ MACDä½é»é–¥å€¼æ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="macdBuyToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="macdBuyToggle">é¡¯ç¤ºä½é»æ¨™è¨˜ï¼ˆå¢¨ç¶ è‰²ï¼‰</label>
            </div>
            <div class="range-input">
                <label>ä½é»é–¾å€¼ï¼ˆD-Mè² å€¼åè½‰å¾Œä½æ–¼æ­¤å€¼ï¼‰:</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="macdBuyThresholdRange" min="-1500" max="1500" step="5" value="0">
                        </div>
                        <div class="range-labels">
                            <span>-1500</span>
                            <span>1500</span>
                        </div>
                    </div>
                    <input type="number" id="macdBuyThreshold" min="-1500" max="1500" step="5" value="0">
                </div>
            </div>
            <p style="font-size: 0.85em; color: #666; margin: 8px 0 0 0; line-height: 1.4;">
                ç•¶ MACD D-M å¾è² å€¼å€å‘ä¸Šåè½‰ï¼Œä¸”åè½‰å¾Œçš„å€¼ä½æ–¼é–¾å€¼æ™‚æ¨™è¨˜
            </p>
        </div>
    </div>
</div>

<!-- é«˜æª”å€åŸŸæµ®å‹•æ§åˆ¶é¢æ¿ -->
<div class="floating-panel" id="highPricePanel">
    <button class="panel-toggle" id="highPanelToggle">âš™ï¸</button>
    <div class="panel-content">
        <div class="panel-section">
            <h3>é«˜æª”å€åŸŸæ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="highMasterToggle">
                    <span class="toggle-slider"></span>
                </label>
                <label for="highMasterToggle" style="font-size: 1em; font-weight: 500;">é–‹å•Ÿæ‰€æœ‰é«˜æª”æ¨™è¨˜</label>
            </div>
        </div>

        <div class="panel-section" data-indicator="macd" id="highMacdSection">
            <h3>ğŸ“ˆ MACD æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>é«˜æª”å€åŸŸ (é«˜æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="highMacdThresholdRange" class="macd-range" min="-500" max="1000" step="5" value="0">
                        </div>
                        <div class="range-labels macd-labels">
                            <span>-500</span>
                            <span>1000</span>
                        </div>
                    </div>
                    <input type="number" id="highMacdThreshold" min="-500" max="1000" step="5" value="0">
                </div>
            </div>
        </div>

        <div class="panel-section" data-indicator="kd" id="highKdSection">
            <h3>ğŸ“Š KD æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>è¶…è²·å€åŸŸ (é«˜æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="highKdThresholdRange" class="kd-range" min="20" max="100" step="1" value="70">
                        </div>
                        <div class="range-labels">
                            <span>20</span>
                            <span>100</span>
                        </div>
                    </div>
                    <input type="number" id="highKdThreshold" min="20" max="100" step="1" value="70">
                </div>
            </div>
        </div>

        <div class="panel-section" data-indicator="rsi" id="highRsiSection">
            <h3>ğŸ“ˆ RSI æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>è¶…è²·å€åŸŸ (é«˜æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="highRsiThresholdRange" class="rsi-range" min="20" max="100" step="1" value="70">
                        </div>
                        <div class="range-labels rsi-labels">
                            <span>20</span>
                            <span>100</span>
                        </div>
                    </div>
                    <input type="number" id="highRsiThreshold" min="20" max="100" step="1" value="70">
                </div>
            </div>
        </div>

        <div class="panel-section">
            <h3>ğŸ¯ Kç·šå€è¤‡åˆæ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="highCompositeMACD" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="highCompositeMACD">æ¡ç”¨ MACD æ¢ä»¶</label>
            </div>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="highCompositeKD" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="highCompositeKD">æ¡ç”¨ KD æ¢ä»¶</label>
            </div>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="highCompositeRSI" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="highCompositeRSI">æ¡ç”¨ RSI æ¢ä»¶</label>
            </div>
        </div>
    </div>
</div>

<!-- ä½æª”å€åŸŸæµ®å‹•æ§åˆ¶é¢æ¿ -->
<div class="floating-panel" id="lowPricePanel">
    <button class="panel-toggle" id="lowPanelToggle">âš™ï¸</button>
    <div class="panel-content">
        <div class="panel-section">
            <h3>ä½æª”å€åŸŸæ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="masterToggle">
                    <span class="toggle-slider"></span>
                </label>
                <label for="masterToggle" style="font-size: 1em; font-weight: 500;">é–‹å•Ÿæ‰€æœ‰ä½æª”æ¨™è¨˜</label>
            </div>
        </div>

        <div class="panel-section" data-indicator="macd">
            <h3>ğŸ“‰ MACD æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>ä½æª”å€åŸŸ (ä½æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="macdThresholdRange" class="macd-range" min="-1000" max="500" step="5" value="0">
                        </div>
                        <div class="range-labels macd-labels">
                            <span>-1000</span>
                            <span>500</span>
                        </div>
                    </div>
                    <input type="number" id="macdThreshold" min="-1000" max="500" step="5" value="0">
                </div>
            </div>
        </div>

        <div class="panel-section" data-indicator="kd">
            <h3>ğŸ“Š KD æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>è¶…è³£å€åŸŸ (ä½æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="kdThresholdRange" class="kd-range" min="0" max="80" step="1" value="30">
                        </div>
                        <div class="range-labels">
                            <span>0</span>
                            <span>80</span>
                        </div>
                    </div>
                    <input type="number" id="kdThreshold" min="0" max="80" step="1" value="30">
                </div>
            </div>
        </div>

        <div class="panel-section" data-indicator="rsi">
            <h3>ğŸ“ˆ RSI æŒ‡æ¨™è¨­å®š</h3>
            <div class="range-input">
                <label>è¶…è³£å€åŸŸ (ä½æ–¼):</label>
                <div class="range-control">
                    <div class="range-slider-container">
                        <div class="range-slider-wrapper">
                            <input type="range" id="rsiThresholdRange" class="rsi-range" min="0" max="80" step="1" value="30">
                        </div>
                        <div class="range-labels rsi-labels">
                            <span>0</span>
                            <span>80</span>
                        </div>
                    </div>
                    <input type="number" id="rsiThreshold" min="0" max="80" step="1" value="30">
                </div>
            </div>
        </div>

        <div class="panel-section">
            <h3>ğŸ¯ Kç·šå€è¤‡åˆæ¨™è¨˜</h3>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="compositeMACD" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="compositeMACD">æ¡ç”¨ MACD æ¢ä»¶</label>
            </div>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="compositeKD" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="compositeKD">æ¡ç”¨ KD æ¢ä»¶</label>
            </div>
            <div class="zone-checkbox">
                <label class="toggle-switch">
                    <input type="checkbox" id="compositeRSI" checked>
                    <span class="toggle-slider"></span>
                </label>
                <label for="compositeRSI">æ¡ç”¨ RSI æ¢ä»¶</label>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 0. è¨­å®š Day.js ---
    dayjs.extend(window.dayjs_plugin_weekOfYear);

    // --- 1. [Utils] æ•¸å­¸è¨ˆç®—å·¥å…· (æ¡ç”¨SMAé ç†±ï¼Œå‘½åèˆ‡æ¨¹ç²¾éˆåŒæ­¥) ---
    const TechUtils = {
        calculateSMA: (data, period) => {
            if (!data || data.length < period) {
                return new Array(data.length).fill(null);
            }
            const smaArray = new Array(data.length).fill(null);
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i];
                if (i >= period) {
                    sum -= data[i - period];
                    smaArray[i] = sum / period;
                } else if (i === period - 1) {
                    smaArray[i] = sum / period;
                }
            }
            return smaArray;
        },

        calculateEMA: (data, period) => {
            if (!data || data.length < period) {
                return new Array(data.length).fill(null);
            }

            const k = 2 / (period + 1);
            const emaArray = new Array(data.length).fill(null);

            let sma = 0;
            for (let i = 0; i < period; i++) {
                sma += data[i];
            }
            emaArray[period - 1] = sma / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }

            return emaArray;
        },

        calculateMACD: (closePrices, shortPeriod = 12, longPeriod = 26, midPeriod = 9) => {
            const totalLength = closePrices.length;
            if (totalLength < longPeriod + midPeriod -1) {
                return { dif: [], macd: [], dm: [] };
            }

            const shortEMA = TechUtils.calculateEMA(closePrices, shortPeriod);
            const longEMA = TechUtils.calculateEMA(closePrices, longPeriod);

            const dif = new Array(totalLength).fill(null);
            for (let i = longPeriod - 1; i < totalLength; i++) {
                if (longEMA[i] !== null && shortEMA[i] !== null) {
                     dif[i] = shortEMA[i] - longEMA[i];
                }
            }

            const difValues = dif.slice(longPeriod - 1);
            const macdValues = TechUtils.calculateEMA(difValues, midPeriod);

            const macd = new Array(totalLength).fill(null);
            for (let i = 0; i < macdValues.length; i++) {
                if (macdValues[i] !== null) {
                    macd[i + longPeriod - 1] = macdValues[i];
                }
            }
            
            const dm = new Array(totalLength).fill(null);
            const startIndex = longPeriod - 1 + midPeriod - 1;
            for (let i = startIndex; i < totalLength; i++) {
                 if (dif[i] !== null && macd[i] !== null) {
                    dm[i] = dif[i] - macd[i];
                 }
            }

            return { dif, macd, dm };
        },

        calculateKD: (data, kPeriod = 9, dPeriod = 3) => {
            const totalLength = data.length;
            if (totalLength < kPeriod) {
                return { k: [], d: [] };
            }

            const rsvArray = new Array(totalLength).fill(null);

            for (let i = kPeriod - 1; i < totalLength; i++) {
                let highestHigh = -Infinity;
                let lowestLow = Infinity;

                for (let j = i - kPeriod + 1; j <= i; j++) {
                    if (data[j].high > highestHigh) highestHigh = data[j].high;
                    if (data[j].low < lowestLow) lowestLow = data[j].low;
                }

                const range = highestHigh - lowestLow;
                if (range !== 0) {
                    rsvArray[i] = ((data[i].close - lowestLow) / range) * 100;
                } else {
                    rsvArray[i] = 50;
                }
            }

            const kArray = new Array(totalLength).fill(null);
            kArray[kPeriod - 1] = rsvArray[kPeriod - 1];

            for (let i = kPeriod; i < totalLength; i++) {
                if (rsvArray[i] !== null && kArray[i - 1] !== null) {
                    kArray[i] = (kArray[i - 1] * 2 / 3) + (rsvArray[i] * 1 / 3);
                }
            }

            const dArray = new Array(totalLength).fill(null);
            dArray[kPeriod - 1] = kArray[kPeriod - 1];

            for (let i = kPeriod; i < totalLength; i++) {
                if (kArray[i] !== null && dArray[i - 1] !== null) {
                    dArray[i] = (dArray[i - 1] * 2 / 3) + (kArray[i] * 1 / 3);
                }
            }

            return { k: kArray, d: dArray };
        },

        calculateRSI: (closePrices, period = 14) => {
            const totalLength = closePrices.length;
            if (totalLength < period + 1) {
                return new Array(totalLength).fill(null);
            }

            const rsiArray = new Array(totalLength).fill(null);
            let avgGain = 0;
            let avgLoss = 0;

            for (let i = 1; i <= period; i++) {
                const change = closePrices[i] - closePrices[i - 1];
                if (change > 0) {
                    avgGain += change;
                } else {
                    avgLoss += Math.abs(change);
                }
            }
            avgGain /= period;
            avgLoss /= period;

            if (avgLoss === 0) {
                rsiArray[period] = 100;
            } else {
                const rs = avgGain / avgLoss;
                rsiArray[period] = 100 - (100 / (1 + rs));
            }

            for (let i = period + 1; i < totalLength; i++) {
                const change = closePrices[i] - closePrices[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;

                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;

                if (avgLoss === 0) {
                    rsiArray[i] = 100;
                } else {
                    const rs = avgGain / avgLoss;
                    rsiArray[i] = 100 - (100 / (1 + rs));
                }
            }

            return rsiArray;
        }
    };

    // --- 2. [Service] è³‡æ–™è™•ç†å±¤ (æ”¹ç‚ºä¸²æ¥çœŸå¯¦ API) ---
    const DataService = {
        fetchRealData: async () => {
            const API_URL = 'https://api.finmindtrade.com/api/v4/data?dataset=TaiwanStockPrice&data_id=TAIEX&start_date=1997-01-01';
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                const result = await response.json();
                if (result.data && result.data.length > 0) {
                    return result.data.map(item => ({
                        date: item.date,
                        open: item.open,
                        high: item.max,
                        low: item.min,
                        close: item.close,
                        values: [item.open, item.close, item.min, item.max]
                    }));
                } else {
                    throw new Error('No data received from API');
                }
            } catch (error) {
                console.error("Failed to fetch real data:", error);
                return [];
            }
        },

        resampleToPeriod: (dailyData, periodType) => {
            if (periodType === 'daily') {
                return dailyData.map(d => ({ ...d, date: d.date }));
            }

            const grouped = {};
            dailyData.forEach(tick => {
                const d = dayjs(tick.date);
                let key;
                switch (periodType) {
                    case 'weekly':
                        key = `${d.year()}-W${String(d.week()).padStart(2, '0')}`;
                        break;
                    case 'bi-weekly':
                        const biWeekIndex = Math.floor(d.week() / 2);
                        key = `${d.year()}-BW${String(biWeekIndex).padStart(2, '0')}`;
                        break;
                    case 'tri-weekly':
                        const triWeekIndex = Math.floor(d.week() / 3);
                        key = `${d.year()}-TW${String(triWeekIndex).padStart(2, '0')}`;
                        break;
                    case 'monthly':
                        key = d.format('YYYY-MM');
                        break;
                }

                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(tick);
            });

            return Object.keys(grouped).sort().map(key => {
                const ticks = grouped[key];
                const firstTick = ticks[0];
                const lastTick = ticks[ticks.length - 1];

                const open = firstTick.open;
                const close = lastTick.close;
                const high = Math.max(...ticks.map(t => t.high));
                const low = Math.min(...ticks.map(t => t.low));
                
                const displayDate = `${firstTick.date} ~ ${lastTick.date}`;

                return { 
                    date: displayDate,
                    open, 
                    close, 
                    high, 
                    low, 
                    values: [open, close, low, high] 
                };
            });
        }
    };

    // --- 3. [View] æ¸²æŸ“å±¤ (æ”¹ç‚ºéåŒæ­¥ async function) ---
    async function initApp() {
        const statusEl = document.getElementById('status');
        const chartTitleEl = document.getElementById('chart-title');
        const chartDom = document.getElementById('chart');
        const myChart = echarts.init(chartDom);
        const controlButtons = document.querySelectorAll('.btn');

        // æµ®å‹•é¢æ¿æ§åˆ¶
        const macdReversalPanel = document.getElementById('macdReversalPanel');
        const highPricePanel = document.getElementById('highPricePanel');
        const lowPricePanel = document.getElementById('lowPricePanel');
        const macdReversalPanelToggle = document.getElementById('macdReversalPanelToggle');
        const highPanelToggle = document.getElementById('highPanelToggle');
        const lowPanelToggle = document.getElementById('lowPanelToggle');
        const macdReversalBookmark = document.getElementById('macdReversalBookmark');
        const highPriceAreaBookmark = document.getElementById('highPriceAreaBookmark');
        const lowPriceAreaBookmark = document.getElementById('lowPriceAreaBookmark');
        const sidebar = document.querySelector('.sidebar');

        // é—œé–‰æ‰€æœ‰é¢æ¿
        function closeAllPanels() {
            macdReversalPanel.classList.remove('open');
            highPricePanel.classList.remove('open');
            lowPricePanel.classList.remove('open');
            sidebar.classList.remove('panel-open');
            macdReversalBookmark.classList.remove('active');
            highPriceAreaBookmark.classList.remove('active');
            lowPriceAreaBookmark.classList.remove('active');
        }

        // åˆ‡æ›MACDåè½‰é¢æ¿
        function toggleMacdReversalPanel() {
            const wasOpen = macdReversalPanel.classList.contains('open');
            closeAllPanels();
            if (!wasOpen) {
                macdReversalPanel.classList.add('open');
                sidebar.classList.add('panel-open');
                macdReversalBookmark.classList.add('active');
            }
        }

        // åˆ‡æ›é«˜æª”å€åŸŸé¢æ¿
        function toggleHighPanel() {
            const wasOpen = highPricePanel.classList.contains('open');
            closeAllPanels();
            if (!wasOpen) {
                highPricePanel.classList.add('open');
                sidebar.classList.add('panel-open');
                highPriceAreaBookmark.classList.add('active');
            }
        }

        // åˆ‡æ›ä½æª”å€åŸŸé¢æ¿
        function toggleLowPanel() {
            const wasOpen = lowPricePanel.classList.contains('open');
            closeAllPanels();
            if (!wasOpen) {
                lowPricePanel.classList.add('open');
                sidebar.classList.add('panel-open');
                lowPriceAreaBookmark.classList.add('active');
            }
        }

        // ç¶å®šMACDåè½‰æ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
        macdReversalPanelToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMacdReversalPanel();
        });

        macdReversalBookmark.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMacdReversalPanel();
        });

        // ç¶å®šé«˜æª”å€åŸŸæ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
        highPanelToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleHighPanel();
        });

        highPriceAreaBookmark.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleHighPanel();
        });

        // ç¶å®šä½æª”å€åŸŸæ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
        lowPanelToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleLowPanel();
        });

        lowPriceAreaBookmark.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleLowPanel();
        });

        // é»æ“Šé¢æ¿å¤–éƒ¨é—œé–‰é¢æ¿
        document.addEventListener('click', (e) => {
            const isClickInsideMacdReversalPanel = macdReversalPanel.contains(e.target);
            const isClickInsideHighPanel = highPricePanel.contains(e.target);
            const isClickInsideLowPanel = lowPricePanel.contains(e.target);
            const isClickOnSidebar = sidebar.contains(e.target);
            const isAnyPanelOpen = macdReversalPanel.classList.contains('open') || highPricePanel.classList.contains('open') || lowPricePanel.classList.contains('open');

            // å¦‚æœæœ‰é¢æ¿æ˜¯é–‹å•Ÿçš„ï¼Œä¸”é»æ“Šä¸åœ¨ä»»ä½•é¢æ¿å…§ï¼Œä¹Ÿä¸åœ¨å´é‚Šæ¬„ä¸Šï¼Œå‰‡é—œé–‰æ‰€æœ‰é¢æ¿
            if (isAnyPanelOpen && !isClickInsideMacdReversalPanel && !isClickInsideHighPanel && !isClickInsideLowPanel && !isClickOnSidebar) {
                closeAllPanels();
            }
        });

        // é˜²æ­¢é»æ“Šé¢æ¿å…§éƒ¨æ™‚é—œé–‰é¢æ¿
        macdReversalPanel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        highPricePanel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        lowPricePanel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // å€åŸŸæ¨™è¨˜ç‹€æ…‹ç®¡ç†
        let zoneMarkingState = {
            masterEnabled: false,  // é è¨­é—œé–‰ä½æª”æ¨™è¨˜
            kd: { enabled: true, threshold: 30 },
            rsi: { enabled: true, threshold: 30 },
            macd: { enabled: true, threshold: 0 },
            composite: {
                useKD: true,
                useRSI: true,
                useMACD: true
            },
            // é«˜æª”å€åŸŸæ¨™è¨˜
            highMasterEnabled: false,  // é è¨­é—œé–‰é«˜æª”æ¨™è¨˜
            highKd: { enabled: true, threshold: 70 },
            highRsi: { enabled: true, threshold: 70 },
            highMacd: { enabled: true, threshold: 0 },
            highComposite: {
                useKD: true,
                useRSI: true,
                useMACD: true
            },
            // MACDè²·è³£é»æ¨™è¨˜
            macdBuySell: {
                masterEnabled: false,  // è²·è³£é»ç¸½é–‹é—œï¼ˆé è¨­é—œé–‰ï¼‰
                sellEnabled: true,     // é è¨­é–‹å•Ÿè³£é»æ¨™è¨˜
                buyEnabled: true,      // é è¨­é–‹å•Ÿè²·é»æ¨™è¨˜
                sellThreshold: 0,      // è³£é»é–¾å€¼ï¼ˆæ­£å€¼åè½‰ï¼‰
                buyThreshold: 0        // è²·é»é–¾å€¼ï¼ˆè² å€¼åè½‰ï¼‰
            }
        };

        statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: #3498db;">æ­£åœ¨å¾ FinMind API ç²å–çœŸå¯¦å°è‚¡åŠ æ¬ŠæŒ‡æ•¸æ­·å²è³‡æ–™...</span>`;

        console.time("FetchRealData");
        const dailyData = await DataService.fetchRealData();
        console.timeEnd("FetchRealData");
        
        if (dailyData.length === 0) {
             statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: red;">ç²å–çœŸå¯¦è³‡æ–™å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚åœ–è¡¨ç„¡æ³•è¼‰å…¥ã€‚</span>`;
             return;
        }

        statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šçœŸå¯¦è³‡æ–™è¼‰å…¥æˆåŠŸï¼Œè«‹é¸æ“‡æ™‚é–“é€±æœŸã€‚`;

        let currentPeriod = 'daily';
        let lastClickedIndex = null; // ç”¨æ–¼è¿½è¹¤é»æ“Šçš„Kæ£’ï¼Œå¯¦ç¾åå­—ç·šåˆ‡æ›
        let indicatorVisible = {
            macd: true,
            kd: true,
            rsi: true
        };

        // ä¸»é–‹é—œæ§åˆ¶
        const masterToggle = document.getElementById('masterToggle');
        masterToggle.addEventListener('change', () => {
            zoneMarkingState.masterEnabled = masterToggle.checked;
            updateChartMarkingsOnly();
        });

        // KD è¨­å®šæ§åˆ¶
        const kdThresholdRange = document.getElementById('kdThresholdRange');
        const kdThresholdInput = document.getElementById('kdThreshold');

        // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
        kdThresholdRange.addEventListener('input', () => {
            const value = parseInt(kdThresholdRange.value);
            kdThresholdInput.value = value;
            zoneMarkingState.kd.threshold = value;
            updateChartMarkingsOnly();
        });

        kdThresholdInput.addEventListener('input', () => {
            let value = parseInt(kdThresholdInput.value);
            // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
            if (isNaN(value)) value = 30;
            value = Math.max(0, Math.min(80, value));
            // èª¿æ•´ç‚ºæ•´æ•¸
            value = Math.round(value);
            kdThresholdInput.value = value;
            kdThresholdRange.value = value;
            zoneMarkingState.kd.threshold = value;
            updateChartMarkingsOnly();
        });

        kdThresholdInput.addEventListener('blur', () => {
            // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
            let value = parseInt(kdThresholdInput.value);
            if (isNaN(value)) value = 30;
            value = Math.max(0, Math.min(80, value));
            value = Math.round(value);
            kdThresholdInput.value = value;
            kdThresholdRange.value = value;
            zoneMarkingState.kd.threshold = value;
            updateChartMarkingsOnly();
        });

        // RSI è¨­å®šæ§åˆ¶
        const rsiThresholdRange = document.getElementById('rsiThresholdRange');
        const rsiThresholdInput = document.getElementById('rsiThreshold');

        // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
        rsiThresholdRange.addEventListener('input', () => {
            const value = parseInt(rsiThresholdRange.value);
            rsiThresholdInput.value = value;
            zoneMarkingState.rsi.threshold = value;
            updateChartMarkingsOnly();
        });

        rsiThresholdInput.addEventListener('input', () => {
            let value = parseInt(rsiThresholdInput.value);
            // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
            if (isNaN(value)) value = 30;
            value = Math.max(0, Math.min(80, value));
            // èª¿æ•´ç‚ºæ•´æ•¸
            value = Math.round(value);
            rsiThresholdInput.value = value;
            rsiThresholdRange.value = value;
            zoneMarkingState.rsi.threshold = value;
            updateChartMarkingsOnly();
        });

        rsiThresholdInput.addEventListener('blur', () => {
            // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
            let value = parseInt(rsiThresholdInput.value);
            if (isNaN(value)) value = 30;
            value = Math.max(0, Math.min(80, value));
            value = Math.round(value);
            rsiThresholdInput.value = value;
            rsiThresholdRange.value = value;
            zoneMarkingState.rsi.threshold = value;
            updateChartMarkingsOnly();
        });

        // MACD è¨­å®šæ§åˆ¶
        const macdThresholdRange = document.getElementById('macdThresholdRange');
        const macdThresholdInput = document.getElementById('macdThreshold');

        // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
        macdThresholdRange.addEventListener('input', () => {
            const value = parseInt(macdThresholdRange.value);
            macdThresholdInput.value = value;
            zoneMarkingState.macd.threshold = value;
            updateChartMarkingsOnly();
        });

        macdThresholdInput.addEventListener('input', () => {
            let value = parseInt(macdThresholdInput.value);
            // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(500, value));
            // èª¿æ•´ç‚ºæ­¥é€²å€¼çš„å€æ•¸ (5)
            value = Math.round(value / 5) * 5;
            macdThresholdInput.value = value;
            macdThresholdRange.value = value;
            zoneMarkingState.macd.threshold = value;
            updateChartMarkingsOnly();
        });

        macdThresholdInput.addEventListener('blur', () => {
            // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
            let value = parseInt(macdThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(500, value));
            value = Math.round(value / 5) * 5;
            macdThresholdInput.value = value;
            macdThresholdRange.value = value;
            zoneMarkingState.macd.threshold = value;
            updateChartMarkingsOnly();
        });

        // è¤‡åˆæ¨™è¨˜æ§åˆ¶
        const compositeKD = document.getElementById('compositeKD');
        const compositeRSI = document.getElementById('compositeRSI');
        const compositeMACD = document.getElementById('compositeMACD');

        // ç²å–å°æ‡‰çš„é¢æ¿å€å¡Šï¼ˆé™å®šåœ¨ä½æª”å€åŸŸé¢æ¿å…§ï¼‰
        const kdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="kd"]');
        const rsiPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="rsi"]');
        const macdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="macd"]');

        compositeKD.addEventListener('change', () => {
            zoneMarkingState.composite.useKD = compositeKD.checked;
            // æ§åˆ¶ KD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
            if (compositeKD.checked) {
                kdPanelSection.classList.remove('hidden');
            } else {
                kdPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });
        compositeRSI.addEventListener('change', () => {
            zoneMarkingState.composite.useRSI = compositeRSI.checked;
            // æ§åˆ¶ RSI è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
            if (compositeRSI.checked) {
                rsiPanelSection.classList.remove('hidden');
            } else {
                rsiPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });
        compositeMACD.addEventListener('change', () => {
            zoneMarkingState.composite.useMACD = compositeMACD.checked;
            // æ§åˆ¶ MACD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
            if (compositeMACD.checked) {
                macdPanelSection.classList.remove('hidden');
            } else {
                macdPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });

        // === é«˜æª”å€åŸŸæ§åˆ¶ ===

        // é«˜æª”ä¸»é–‹é—œæ§åˆ¶
        const highMasterToggle = document.getElementById('highMasterToggle');
        highMasterToggle.addEventListener('change', () => {
            zoneMarkingState.highMasterEnabled = highMasterToggle.checked;
            updateChartMarkingsOnly();
        });

        // é«˜æª” KD è¨­å®šæ§åˆ¶
        const highKdThresholdRange = document.getElementById('highKdThresholdRange');
        const highKdThresholdInput = document.getElementById('highKdThreshold');

        highKdThresholdRange.addEventListener('input', () => {
            const value = parseInt(highKdThresholdRange.value);
            highKdThresholdInput.value = value;
            zoneMarkingState.highKd.threshold = value;
            updateChartMarkingsOnly();
        });

        highKdThresholdInput.addEventListener('input', () => {
            let value = parseInt(highKdThresholdInput.value);
            if (isNaN(value)) value = 70;
            value = Math.max(20, Math.min(100, value));
            value = Math.round(value);
            highKdThresholdInput.value = value;
            highKdThresholdRange.value = value;
            zoneMarkingState.highKd.threshold = value;
            updateChartMarkingsOnly();
        });

        highKdThresholdInput.addEventListener('blur', () => {
            let value = parseInt(highKdThresholdInput.value);
            if (isNaN(value)) value = 70;
            value = Math.max(20, Math.min(100, value));
            value = Math.round(value);
            highKdThresholdInput.value = value;
            highKdThresholdRange.value = value;
            zoneMarkingState.highKd.threshold = value;
            updateChartMarkingsOnly();
        });

        // é«˜æª” RSI è¨­å®šæ§åˆ¶
        const highRsiThresholdRange = document.getElementById('highRsiThresholdRange');
        const highRsiThresholdInput = document.getElementById('highRsiThreshold');

        highRsiThresholdRange.addEventListener('input', () => {
            const value = parseInt(highRsiThresholdRange.value);
            highRsiThresholdInput.value = value;
            zoneMarkingState.highRsi.threshold = value;
            updateChartMarkingsOnly();
        });

        highRsiThresholdInput.addEventListener('input', () => {
            let value = parseInt(highRsiThresholdInput.value);
            if (isNaN(value)) value = 70;
            value = Math.max(20, Math.min(100, value));
            value = Math.round(value);
            highRsiThresholdInput.value = value;
            highRsiThresholdRange.value = value;
            zoneMarkingState.highRsi.threshold = value;
            updateChartMarkingsOnly();
        });

        highRsiThresholdInput.addEventListener('blur', () => {
            let value = parseInt(highRsiThresholdInput.value);
            if (isNaN(value)) value = 70;
            value = Math.max(20, Math.min(100, value));
            value = Math.round(value);
            highRsiThresholdInput.value = value;
            highRsiThresholdRange.value = value;
            zoneMarkingState.highRsi.threshold = value;
            updateChartMarkingsOnly();
        });

        // é«˜æª” MACD è¨­å®šæ§åˆ¶
        const highMacdThresholdRange = document.getElementById('highMacdThresholdRange');
        const highMacdThresholdInput = document.getElementById('highMacdThreshold');

        highMacdThresholdRange.addEventListener('input', () => {
            const value = parseInt(highMacdThresholdRange.value);
            highMacdThresholdInput.value = value;
            zoneMarkingState.highMacd.threshold = value;
            updateChartMarkingsOnly();
        });

        highMacdThresholdInput.addEventListener('input', () => {
            let value = parseInt(highMacdThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-500, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            highMacdThresholdInput.value = value;
            highMacdThresholdRange.value = value;
            zoneMarkingState.highMacd.threshold = value;
            updateChartMarkingsOnly();
        });

        highMacdThresholdInput.addEventListener('blur', () => {
            let value = parseInt(highMacdThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-500, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            highMacdThresholdInput.value = value;
            highMacdThresholdRange.value = value;
            zoneMarkingState.highMacd.threshold = value;
            updateChartMarkingsOnly();
        });

        // é«˜æª”è¤‡åˆæ¨™è¨˜æ§åˆ¶
        const highCompositeKD = document.getElementById('highCompositeKD');
        const highCompositeRSI = document.getElementById('highCompositeRSI');
        const highCompositeMACD = document.getElementById('highCompositeMACD');

        const highKdPanelSection = document.getElementById('highKdSection');
        const highRsiPanelSection = document.getElementById('highRsiSection');
        const highMacdPanelSection = document.getElementById('highMacdSection');

        highCompositeKD.addEventListener('change', () => {
            zoneMarkingState.highComposite.useKD = highCompositeKD.checked;
            if (highCompositeKD.checked) {
                highKdPanelSection.classList.remove('hidden');
            } else {
                highKdPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });

        highCompositeRSI.addEventListener('change', () => {
            zoneMarkingState.highComposite.useRSI = highCompositeRSI.checked;
            if (highCompositeRSI.checked) {
                highRsiPanelSection.classList.remove('hidden');
            } else {
                highRsiPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });

        highCompositeMACD.addEventListener('change', () => {
            zoneMarkingState.highComposite.useMACD = highCompositeMACD.checked;
            if (highCompositeMACD.checked) {
                highMacdPanelSection.classList.remove('hidden');
            } else {
                highMacdPanelSection.classList.add('hidden');
            }
            updateChartMarkingsOnly();
        });

        // === MACDè²·è³£é»æ§åˆ¶ ===
        const macdBuySellMasterToggle = document.getElementById('macdBuySellMasterToggle');
        const macdSellToggle = document.getElementById('macdSellToggle');
        const macdBuyToggle = document.getElementById('macdBuyToggle');
        const macdSellThresholdRange = document.getElementById('macdSellThresholdRange');
        const macdSellThresholdInput = document.getElementById('macdSellThreshold');
        const macdBuyThresholdRange = document.getElementById('macdBuyThresholdRange');
        const macdBuyThresholdInput = document.getElementById('macdBuyThreshold');

        // è²·è³£é»ç¸½é–‹é—œ
        macdBuySellMasterToggle.addEventListener('change', () => {
            zoneMarkingState.macdBuySell.masterEnabled = macdBuySellMasterToggle.checked;
            updateChartMarkingsOnly();
        });

        // è³£é»é–‹é—œ
        macdSellToggle.addEventListener('change', () => {
            zoneMarkingState.macdBuySell.sellEnabled = macdSellToggle.checked;
            updateChartMarkingsOnly();
        });

        // è²·é»é–‹é—œ
        macdBuyToggle.addEventListener('change', () => {
            zoneMarkingState.macdBuySell.buyEnabled = macdBuyToggle.checked;
            updateChartMarkingsOnly();
        });

        // è³£é»é–¾å€¼æ§åˆ¶
        macdSellThresholdRange.addEventListener('input', () => {
            const value = parseInt(macdSellThresholdRange.value);
            macdSellThresholdInput.value = value;
            zoneMarkingState.macdBuySell.sellThreshold = value;
            updateChartMarkingsOnly();
        });

        macdSellThresholdInput.addEventListener('input', () => {
            let value = parseInt(macdSellThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            macdSellThresholdInput.value = value;
            macdSellThresholdRange.value = value;
            zoneMarkingState.macdBuySell.sellThreshold = value;
            updateChartMarkingsOnly();
        });

        macdSellThresholdInput.addEventListener('blur', () => {
            let value = parseInt(macdSellThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            macdSellThresholdInput.value = value;
            macdSellThresholdRange.value = value;
            zoneMarkingState.macdBuySell.sellThreshold = value;
            updateChartMarkingsOnly();
        });

        // è²·é»é–¾å€¼æ§åˆ¶
        macdBuyThresholdRange.addEventListener('input', () => {
            const value = parseInt(macdBuyThresholdRange.value);
            macdBuyThresholdInput.value = value;
            zoneMarkingState.macdBuySell.buyThreshold = value;
            updateChartMarkingsOnly();
        });

        macdBuyThresholdInput.addEventListener('input', () => {
            let value = parseInt(macdBuyThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            macdBuyThresholdInput.value = value;
            macdBuyThresholdRange.value = value;
            zoneMarkingState.macdBuySell.buyThreshold = value;
            updateChartMarkingsOnly();
        });

        macdBuyThresholdInput.addEventListener('blur', () => {
            let value = parseInt(macdBuyThresholdInput.value);
            if (isNaN(value)) value = 0;
            value = Math.max(-1000, Math.min(1000, value));
            value = Math.round(value / 5) * 5;
            macdBuyThresholdInput.value = value;
            macdBuyThresholdRange.value = value;
            zoneMarkingState.macdBuySell.buyThreshold = value;
            updateChartMarkingsOnly();
        });

        // å„²å­˜ç•¶å‰åœ–è¡¨æ•¸æ“šï¼Œä¾›æ¨™è¨˜æ›´æ–°ä½¿ç”¨
        let currentChartData = null;

        function updateChartMarkingsOnly() {
            if (!currentChartData) return;

            const option = myChart.getOption();
            const newMarkAreas = generateMarkAreas(currentChartData);

            // æ›´æ–°æ‰€æœ‰éœ€è¦æ¨™è¨˜çš„ç³»åˆ—
            option.series.forEach((s, idx) => {
                if (s.name === currentChartData.periodName) {
                    // Kç·šåœ–çš„è¤‡åˆæ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                    s.markArea = {
                        data: [...newMarkAreas.composite.data, ...newMarkAreas.highComposite.data]
                    };
                    s.markLine = {
                        data: [...newMarkAreas.composite.lines, ...newMarkAreas.highComposite.lines],
                        symbol: 'none',
                        label: { show: false }
                    };
                } else if (s.name === 'ä½æª”åå½ˆæ”¶ç›¤') {
                    // ğŸ¯ æ©˜è‰²æ¨™è¨˜é»ï¼ˆæ•£é»åœ–ï¼‰
                    s.data = newMarkAreas.postZoneMarkers.data;
                } else if (s.name === 'é«˜æª”å›è½æ”¶ç›¤') {
                    // ğŸŸ£ ç´«è‰²æ¨™è¨˜é»ï¼ˆæ•£é»åœ–ï¼‰
                    s.data = newMarkAreas.highPostZoneMarkers.data;
                } else if (s.name === 'è²·é»') {
                    // ğŸ”´ æ·±ç´…è‰²è²·é»ï¼ˆæ•£é»åœ–ï¼‰
                    s.data = (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.buyEnabled)
                        ? newMarkAreas.buySellMarkers.buy : [];
                } else if (s.name === 'è³£é»') {
                    // ğŸŸ¢ å¢¨ç¶ è‰²è³£é»ï¼ˆæ•£é»åœ–ï¼‰
                    s.data = (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.sellEnabled)
                        ? newMarkAreas.buySellMarkers.sell : [];
                } else if (s.name === 'K(9)') {
                    // KD çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                    s.markArea = {
                        data: [...newMarkAreas.kd.data, ...newMarkAreas.highKd.data]
                    };
                    s.markLine = {
                        data: [...newMarkAreas.kd.lines, ...newMarkAreas.highKd.lines],
                        symbol: 'none',
                        label: { show: false }
                    };
                } else if (s.name === 'RSI(5T)') {
                    // RSI çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                    s.markArea = {
                        data: [...newMarkAreas.rsi.data, ...newMarkAreas.highRsi.data]
                    };
                    s.markLine = {
                        data: [...newMarkAreas.rsi.lines, ...newMarkAreas.highRsi.lines],
                        symbol: 'none',
                        label: { show: false }
                    };
                } else if (s.name === 'DIF') {
                    // MACD çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                    s.markArea = {
                        data: [...newMarkAreas.macd.data, ...newMarkAreas.highMacd.data]
                    };
                    s.markLine = {
                        data: [...newMarkAreas.macd.lines, ...newMarkAreas.highMacd.lines],
                        symbol: 'none',
                        label: { show: false }
                    };
                }
            });

            myChart.setOption(option);
        }

        // åªåˆ‡æ›æŒ‡æ¨™é¡¯ç¤º/éš±è—ï¼Œä¸é‡æ–°æ¸²æŸ“åœ–è¡¨ï¼ˆä¿æŒ dataZoom ç‹€æ…‹ï¼‰
        function toggleIndicatorVisibility() {
            if (!currentChartData) return;

            // ç²å–ç•¶å‰çš„ dataZoom ç‹€æ…‹
            const currentOption = myChart.getOption();
            const currentDataZoom = currentOption.dataZoom;

            // å®Œå…¨é‡ç¹ªåœ–è¡¨ï¼ˆå› ç‚ºéœ€è¦èª¿æ•´ grid å’Œ axisï¼‰
            updateChart(currentPeriod);

            // æ¢å¾©ä¹‹å‰çš„ dataZoom ç‹€æ…‹
            setTimeout(() => {
                myChart.setOption({
                    dataZoom: currentDataZoom
                });
            }, 0);
        }

        function generateMarkAreas(data) {
            const { resampledData, kdResult, rsi5, macdResult, periodName } = data;

            // ä½æª”å€åŸŸæ¨™è¨˜åˆå§‹åŒ–
            const postZoneMarkers = { data: [] };
            const highPostZoneMarkers = { data: [] };  // é«˜æª”å€åŸŸå¾Œçš„æ¨™è¨˜é»
            let kdMarkAreas = [];
            let kdMarkLines = [];
            let rsiMarkAreas = [];
            let rsiMarkLines = [];
            let macdMarkAreas = [];
            let macdMarkLines = [];
            let compositeMarkAreas = [];
            let compositeMarkLines = [];

            // === ä½æª”å€åŸŸæ¨™è¨˜é‚è¼¯ ===
            if (!zoneMarkingState.masterEnabled) {
                // ä½æª”æ¨™è¨˜é—œé–‰æ™‚ï¼Œä½¿ç”¨ç©ºé™£åˆ—
                kdMarkAreas = [];
                kdMarkLines = [];
                rsiMarkAreas = [];
                rsiMarkLines = [];
                macdMarkAreas = [];
                macdMarkLines = [];
                compositeMarkAreas = [];
                compositeMarkLines = [];
            } else {
                // ğŸ” æª¢æŸ¥ï¼šå¦‚æœæ‰€æœ‰æŠ€è¡“ç·šåœ–éƒ½é—œé–‰ï¼Œä¸ç”Ÿæˆè¤‡åˆæ¨™è¨˜
                const hasAnyIndicator = zoneMarkingState.composite.useKD ||
                                       zoneMarkingState.composite.useRSI ||
                                       zoneMarkingState.composite.useMACD;

                // KD ä½æª”å€åŸŸæ¨™è¨˜ï¼ˆK å’Œ D éƒ½ä½æ–¼é–¾å€¼æ‰æ¨™è¨˜ï¼‰
                if (indicatorVisible.kd && zoneMarkingState.composite.useKD) {
                let inZone = false;
                let zoneStart = null;
                let zoneStartIndex = null;

                for (let i = 0; i < kdResult.k.length; i++) {
                    const kValue = kdResult.k[i];
                    const dValue = kdResult.d[i];

                    if (kValue !== null && dValue !== null) {
                        // K å’Œ D éƒ½å¿…é ˆä½æ–¼é–¾å€¼ï¼ˆäº¤é›†ï¼‰
                        const isLow = kValue < zoneMarkingState.kd.threshold && dValue < zoneMarkingState.kd.threshold;

                        if (isLow && !inZone) {
                            inZone = true;
                            zoneStart = resampledData[i].date;
                            zoneStartIndex = i;
                        } else if (!isLow && inZone) {
                            const zoneEndIndex = i - 1;
                            // åˆ¤æ–·æ˜¯å–®æ ¹Kæ£’é‚„æ˜¯å€åŸŸ
                            if (zoneStartIndex === zoneEndIndex) {
                                // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                kdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 215, 0, 0.25)', width: 2, type: 'solid' }
                                });
                            } else {
                                // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                kdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 215, 0, 0.25)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                            inZone = false;
                        }
                    }
                }

                if (inZone) {
                    const zoneEndIndex = resampledData.length - 1;
                    if (zoneStartIndex === zoneEndIndex) {
                        kdMarkLines.push({
                            xAxis: zoneStart,
                            lineStyle: { color: 'rgba(255, 215, 0, 0.25)', width: 2, type: 'solid' }
                        });
                    } else {
                        kdMarkAreas.push([
                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 215, 0, 0.25)' } },
                            { xAxis: resampledData[zoneEndIndex].date }
                        ]);
                    }
                }
            }

            // RSI ä½æª”å€åŸŸæ¨™è¨˜
            if (indicatorVisible.rsi && zoneMarkingState.composite.useRSI) {
                let inZone = false;
                let zoneStart = null;
                let zoneStartIndex = null;

                for (let i = 0; i < rsi5.length; i++) {
                    const rsiValue = rsi5[i];

                    if (rsiValue !== null) {
                        const isLow = rsiValue < zoneMarkingState.rsi.threshold;

                        if (isLow && !inZone) {
                            inZone = true;
                            zoneStart = resampledData[i].date;
                            zoneStartIndex = i;
                        } else if (!isLow && inZone) {
                            const zoneEndIndex = i - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                rsiMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(147, 112, 219, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                rsiMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(147, 112, 219, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                            inZone = false;
                        }
                    }
                }

                if (inZone) {
                    const zoneEndIndex = resampledData.length - 1;
                    if (zoneStartIndex === zoneEndIndex) {
                        rsiMarkLines.push({
                            xAxis: zoneStart,
                            lineStyle: { color: 'rgba(147, 112, 219, 0.15)', width: 2, type: 'solid' }
                        });
                    } else {
                        rsiMarkAreas.push([
                            { xAxis: zoneStart, itemStyle: { color: 'rgba(147, 112, 219, 0.15)' } },
                            { xAxis: resampledData[zoneEndIndex].date }
                        ]);
                    }
                }
            }

            // MACD ä½æª”å€åŸŸæ¨™è¨˜
            if (indicatorVisible.macd && zoneMarkingState.composite.useMACD) {
                let inZone = false;
                let zoneStart = null;
                let zoneStartIndex = null;

                for (let i = 0; i < macdResult.dif.length; i++) {
                    const difValue = macdResult.dif[i];

                    if (difValue !== null) {
                        const isLow = difValue < zoneMarkingState.macd.threshold;

                        if (isLow && !inZone) {
                            inZone = true;
                            zoneStart = resampledData[i].date;
                            zoneStartIndex = i;
                        } else if (!isLow && inZone) {
                            const zoneEndIndex = i - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                macdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(0, 213, 250, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                macdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(0, 213, 250, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                            inZone = false;
                        }
                    }
                }

                if (inZone) {
                    const zoneEndIndex = resampledData.length - 1;
                    if (zoneStartIndex === zoneEndIndex) {
                        macdMarkLines.push({
                            xAxis: zoneStart,
                            lineStyle: { color: 'rgba(0, 213, 250, 0.15)', width: 2, type: 'solid' }
                        });
                    } else {
                        macdMarkAreas.push([
                            { xAxis: zoneStart, itemStyle: { color: 'rgba(0, 213, 250, 0.15)' } },
                            { xAxis: resampledData[zoneEndIndex].date }
                        ]);
                    }
                }
            }

            // Kç·šå€è¤‡åˆæ¨™è¨˜ (æ‰€æœ‰é¸ä¸­æ¢ä»¶éƒ½æ»¿è¶³çš„å€åŸŸ)
            // ğŸ” åªæœ‰åœ¨è‡³å°‘æœ‰ä¸€å€‹æŒ‡æ¨™å•Ÿç”¨æ™‚æ‰é€²è¡Œæƒæ
            if (hasAnyIndicator) {
                let inZone = false;
                let zoneStart = null;
                let zoneStartIndex = null;

                for (let i = 0; i < resampledData.length; i++) {
                    let allConditionsMet = true;

                    // æª¢æŸ¥ KD æ¢ä»¶ï¼ˆK å’Œ D éƒ½å¿…é ˆä½æ–¼é–¾å€¼ï¼‰
                    if (zoneMarkingState.composite.useKD) {
                        const kValue = kdResult.k[i];
                        const dValue = kdResult.d[i];
                        if (kValue === null || dValue === null ||
                            kValue >= zoneMarkingState.kd.threshold || dValue >= zoneMarkingState.kd.threshold) {
                            allConditionsMet = false;
                        }
                    }

                // æª¢æŸ¥ RSI æ¢ä»¶
                if (zoneMarkingState.composite.useRSI) {
                    const rsiValue = rsi5[i];
                    if (rsiValue === null || rsiValue >= zoneMarkingState.rsi.threshold) {
                        allConditionsMet = false;
                    }
                }

                // æª¢æŸ¥ MACD æ¢ä»¶
                if (zoneMarkingState.composite.useMACD) {
                    const difValue = macdResult.dif[i];
                    if (difValue === null || difValue >= zoneMarkingState.macd.threshold) {
                        allConditionsMet = false;
                    }
                }

                if (allConditionsMet && !inZone) {
                    inZone = true;
                    zoneStart = resampledData[i].date;
                    zoneStartIndex = i;
                } else if (!allConditionsMet && inZone) {
                    const zoneEndIndex = i - 1;

                    // åˆ¤æ–·æ˜¯å–®æ ¹Kæ£’é‚„æ˜¯å€åŸŸ
                    if (zoneStartIndex === zoneEndIndex) {
                        // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                        compositeMarkLines.push({
                            xAxis: zoneStart,
                            lineStyle: { color: 'rgba(255, 107, 107, 0.15)', width: 3, type: 'solid' }
                        });
                    } else {
                        // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                        compositeMarkAreas.push([
                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 107, 107, 0.15)' } },
                            { xAxis: resampledData[zoneEndIndex].date }
                        ]);
                    }

                    // è¨˜éŒ„ä½æª”å€çµæŸå¾Œçš„ä¸‹ä¸€æ ¹Kæ£’æ”¶ç›¤åƒ¹
                    const nextIndex = i;
                    if (nextIndex < resampledData.length) {
                        const nextCandle = resampledData[nextIndex];

                        // ğŸ” é™¤éŒ¯ï¼šæª¢æŸ¥ä½æª”å€æœ€å¾Œä¸€æ ¹Kæ£’çš„æŒ‡æ¨™å€¼
                        const kValue = kdResult.k[zoneEndIndex];
                        const dValue = kdResult.d[zoneEndIndex];
                        const rsiValue = rsi5[zoneEndIndex];
                        const macdValue = macdResult.dif[zoneEndIndex];

                        const kdOK = (!zoneMarkingState.composite.useKD) ||
                                     (kValue !== null && dValue !== null &&
                                      kValue < zoneMarkingState.kd.threshold &&
                                      dValue < zoneMarkingState.kd.threshold);
                        const rsiOK = (!zoneMarkingState.composite.useRSI) ||
                                      (rsiValue !== null && rsiValue < zoneMarkingState.rsi.threshold);
                        const macdOK = (!zoneMarkingState.composite.useMACD) ||
                                       (macdValue !== null && macdValue < zoneMarkingState.macd.threshold);

                        console.log(`ğŸ¯ #${postZoneMarkers.data.length + 1} [${resampledData[zoneEndIndex].date}]:`, {
                            'K': kValue?.toFixed(1), 'D': dValue?.toFixed(1), 'KDâœ“': kdOK,
                            'RSI': rsiValue?.toFixed(1), 'RSIâœ“': rsiOK,
                            'MACD': macdValue?.toFixed(1), 'MACDâœ“': macdOK,
                            'å…¨ç¬¦åˆ': kdOK && rsiOK && macdOK
                        });

                        postZoneMarkers.data.push([
                            nextIndex,  // x: ç´¢å¼•ä½ç½®
                            nextCandle.close,  // y: æ”¶ç›¤åƒ¹
                            nextCandle.date,  // é¡å¤–è³‡æ–™ï¼šæ—¥æœŸ
                            nextCandle.close  // é¡å¤–è³‡æ–™ï¼šæ”¶ç›¤åƒ¹ï¼ˆç”¨æ–¼æ¨™ç±¤ï¼‰
                        ]);
                    }
                    inZone = false;
                }
            }

            if (inZone) {
                const zoneEndIndex = resampledData.length - 1;
                if (zoneStartIndex === zoneEndIndex) {
                    compositeMarkLines.push({
                        xAxis: zoneStart,
                        lineStyle: { color: 'rgba(255, 107, 107, 0.15)', width: 3, type: 'solid' }
                    });
                } else {
                    compositeMarkAreas.push([
                        { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 107, 107, 0.15)' } },
                        { xAxis: resampledData[zoneEndIndex].date }
                    ]);
                }
            }
            } // çµæŸ hasAnyIndicator æª¢æŸ¥
            } // çµæŸä½æª”å€åŸŸæ¨™è¨˜çš„ else å€å¡Š

            // === é«˜æª”å€åŸŸæ¨™è¨˜ ===
            const highKdMarkAreas = [];
            const highKdMarkLines = [];
            const highRsiMarkAreas = [];
            const highRsiMarkLines = [];
            const highMacdMarkAreas = [];
            const highMacdMarkLines = [];
            const highCompositeMarkAreas = [];
            const highCompositeMarkLines = [];

            if (!zoneMarkingState.highMasterEnabled) {
                // é«˜æª”æ¨™è¨˜é—œé–‰æ™‚ï¼Œè¿”å›ç©ºæ¨™è¨˜
            } else {
                const hasAnyHighIndicator = zoneMarkingState.highComposite.useKD ||
                                           zoneMarkingState.highComposite.useRSI ||
                                           zoneMarkingState.highComposite.useMACD;

                // KD é«˜æª”å€åŸŸæ¨™è¨˜ï¼ˆK å’Œ D éƒ½é«˜æ–¼é–¾å€¼æ‰æ¨™è¨˜ï¼‰
                if (indicatorVisible.kd && zoneMarkingState.highComposite.useKD) {
                    let inZone = false;
                    let zoneStart = null;
                    let zoneStartIndex = null;

                    for (let i = 0; i < kdResult.k.length; i++) {
                        const kValue = kdResult.k[i];
                        const dValue = kdResult.d[i];

                        if (kValue !== null && dValue !== null) {
                            const isHigh = kValue > zoneMarkingState.highKd.threshold && dValue > zoneMarkingState.highKd.threshold;

                            if (isHigh && !inZone) {
                                inZone = true;
                                zoneStart = resampledData[i].date;
                                zoneStartIndex = i;
                            } else if (!isHigh && inZone) {
                                const zoneEndIndex = i - 1;
                                if (zoneStartIndex === zoneEndIndex) {
                                    highKdMarkLines.push({
                                        xAxis: zoneStart,
                                        lineStyle: { color: 'rgba(255, 140, 0, 0.25)', width: 2, type: 'solid' }
                                    });
                                } else {
                                    highKdMarkAreas.push([
                                        { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 140, 0, 0.25)' } },
                                        { xAxis: resampledData[zoneEndIndex].date }
                                    ]);
                                }
                                inZone = false;
                            }
                        }
                    }

                    if (inZone) {
                        const zoneEndIndex = resampledData.length - 1;
                        if (zoneStartIndex === zoneEndIndex) {
                            highKdMarkLines.push({
                                xAxis: zoneStart,
                                lineStyle: { color: 'rgba(255, 140, 0, 0.25)', width: 2, type: 'solid' }
                            });
                        } else {
                            highKdMarkAreas.push([
                                { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 140, 0, 0.25)' } },
                                { xAxis: resampledData[zoneEndIndex].date }
                            ]);
                        }
                    }
                }

                // RSI é«˜æª”å€åŸŸæ¨™è¨˜
                if (indicatorVisible.rsi && zoneMarkingState.highComposite.useRSI) {
                    let inZone = false;
                    let zoneStart = null;
                    let zoneStartIndex = null;

                    for (let i = 0; i < rsi5.length; i++) {
                        const rsiValue = rsi5[i];

                        if (rsiValue !== null) {
                            const isHigh = rsiValue > zoneMarkingState.highRsi.threshold;

                            if (isHigh && !inZone) {
                                inZone = true;
                                zoneStart = resampledData[i].date;
                                zoneStartIndex = i;
                            } else if (!isHigh && inZone) {
                                const zoneEndIndex = i - 1;
                                if (zoneStartIndex === zoneEndIndex) {
                                    highRsiMarkLines.push({
                                        xAxis: zoneStart,
                                        lineStyle: { color: 'rgba(255, 99, 71, 0.15)', width: 2, type: 'solid' }
                                    });
                                } else {
                                    highRsiMarkAreas.push([
                                        { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 99, 71, 0.15)' } },
                                        { xAxis: resampledData[zoneEndIndex].date }
                                    ]);
                                }
                                inZone = false;
                            }
                        }
                    }

                    if (inZone) {
                        const zoneEndIndex = resampledData.length - 1;
                        if (zoneStartIndex === zoneEndIndex) {
                            highRsiMarkLines.push({
                                xAxis: zoneStart,
                                lineStyle: { color: 'rgba(255, 99, 71, 0.15)', width: 2, type: 'solid' }
                            });
                        } else {
                            highRsiMarkAreas.push([
                                { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 99, 71, 0.15)' } },
                                { xAxis: resampledData[zoneEndIndex].date }
                            ]);
                        }
                    }
                }

                // MACD é«˜æª”å€åŸŸæ¨™è¨˜
                if (indicatorVisible.macd && zoneMarkingState.highComposite.useMACD) {
                    let inZone = false;
                    let zoneStart = null;
                    let zoneStartIndex = null;

                    for (let i = 0; i < macdResult.dif.length; i++) {
                        const difValue = macdResult.dif[i];

                        if (difValue !== null) {
                            const isHigh = difValue > zoneMarkingState.highMacd.threshold;

                            if (isHigh && !inZone) {
                                inZone = true;
                                zoneStart = resampledData[i].date;
                                zoneStartIndex = i;
                            } else if (!isHigh && inZone) {
                                const zoneEndIndex = i - 1;
                                if (zoneStartIndex === zoneEndIndex) {
                                    highMacdMarkLines.push({
                                        xAxis: zoneStart,
                                        lineStyle: { color: 'rgba(255, 69, 0, 0.15)', width: 2, type: 'solid' }
                                    });
                                } else {
                                    highMacdMarkAreas.push([
                                        { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 69, 0, 0.15)' } },
                                        { xAxis: resampledData[zoneEndIndex].date }
                                    ]);
                                }
                                inZone = false;
                            }
                        }
                    }

                    if (inZone) {
                        const zoneEndIndex = resampledData.length - 1;
                        if (zoneStartIndex === zoneEndIndex) {
                            highMacdMarkLines.push({
                                xAxis: zoneStart,
                                lineStyle: { color: 'rgba(255, 69, 0, 0.15)', width: 2, type: 'solid' }
                            });
                        } else {
                            highMacdMarkAreas.push([
                                { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 69, 0, 0.15)' } },
                                { xAxis: resampledData[zoneEndIndex].date }
                            ]);
                        }
                    }
                }

                // Kç·šå€é«˜æª”è¤‡åˆæ¨™è¨˜
                if (hasAnyHighIndicator) {
                    let inZone = false;
                    let zoneStart = null;
                    let zoneStartIndex = null;

                    for (let i = 0; i < resampledData.length; i++) {
                        let allConditionsMet = true;

                        if (zoneMarkingState.highComposite.useKD) {
                            const kValue = kdResult.k[i];
                            const dValue = kdResult.d[i];
                            if (kValue === null || dValue === null ||
                                kValue <= zoneMarkingState.highKd.threshold || dValue <= zoneMarkingState.highKd.threshold) {
                                allConditionsMet = false;
                            }
                        }

                        if (zoneMarkingState.highComposite.useRSI) {
                            const rsiValue = rsi5[i];
                            if (rsiValue === null || rsiValue <= zoneMarkingState.highRsi.threshold) {
                                allConditionsMet = false;
                            }
                        }

                        if (zoneMarkingState.highComposite.useMACD) {
                            const difValue = macdResult.dif[i];
                            if (difValue === null || difValue <= zoneMarkingState.highMacd.threshold) {
                                allConditionsMet = false;
                            }
                        }

                        if (allConditionsMet && !inZone) {
                            inZone = true;
                            zoneStart = resampledData[i].date;
                            zoneStartIndex = i;
                        } else if (!allConditionsMet && inZone) {
                            const zoneEndIndex = i - 1;

                            if (zoneStartIndex === zoneEndIndex) {
                                highCompositeMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(220, 20, 60, 0.2)', width: 3, type: 'solid' }
                                });
                            } else {
                                highCompositeMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(220, 20, 60, 0.2)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }

                            // è¨˜éŒ„é«˜æª”å€çµæŸå¾Œçš„ä¸‹ä¸€æ ¹Kæ£’æ”¶ç›¤åƒ¹
                            const nextIndex = i;
                            if (nextIndex < resampledData.length) {
                                const nextCandle = resampledData[nextIndex];

                                // æª¢æŸ¥é«˜æª”å€æœ€å¾Œä¸€æ ¹Kæ£’çš„æŒ‡æ¨™å€¼
                                const kValue = kdResult.k[zoneEndIndex];
                                const dValue = kdResult.d[zoneEndIndex];
                                const rsiValue = rsi5[zoneEndIndex];
                                const macdValue = macdResult.dif[zoneEndIndex];

                                const kdOK = (!zoneMarkingState.highComposite.useKD) ||
                                             (kValue !== null && dValue !== null &&
                                              kValue > zoneMarkingState.highKd.threshold &&
                                              dValue > zoneMarkingState.highKd.threshold);
                                const rsiOK = (!zoneMarkingState.highComposite.useRSI) ||
                                              (rsiValue !== null && rsiValue > zoneMarkingState.highRsi.threshold);
                                const macdOK = (!zoneMarkingState.highComposite.useMACD) ||
                                               (macdValue !== null && macdValue > zoneMarkingState.highMacd.threshold);

                                console.log(`ğŸŸ£ é«˜æª”å€ #${highPostZoneMarkers.data.length + 1} [${resampledData[zoneEndIndex].date}]:`, {
                                    'K': kValue?.toFixed(1), 'D': dValue?.toFixed(1), 'KDâœ“': kdOK,
                                    'RSI': rsiValue?.toFixed(1), 'RSIâœ“': rsiOK,
                                    'MACD': macdValue?.toFixed(1), 'MACDâœ“': macdOK,
                                    'å…¨ç¬¦åˆ': kdOK && rsiOK && macdOK
                                });

                                highPostZoneMarkers.data.push([
                                    nextIndex,  // x: ç´¢å¼•ä½ç½®
                                    nextCandle.close,  // y: æ”¶ç›¤åƒ¹
                                    nextCandle.date,  // é¡å¤–è³‡æ–™ï¼šæ—¥æœŸ
                                    nextCandle.close  // é¡å¤–è³‡æ–™ï¼šæ”¶ç›¤åƒ¹ï¼ˆç”¨æ–¼æ¨™ç±¤ï¼‰
                                ]);
                            }
                            inZone = false;
                        }
                    }

                    if (inZone) {
                        const zoneEndIndex = resampledData.length - 1;
                        if (zoneStartIndex === zoneEndIndex) {
                            highCompositeMarkLines.push({
                                xAxis: zoneStart,
                                lineStyle: { color: 'rgba(220, 20, 60, 0.2)', width: 3, type: 'solid' }
                            });
                        } else {
                            highCompositeMarkAreas.push([
                                { xAxis: zoneStart, itemStyle: { color: 'rgba(220, 20, 60, 0.2)' } },
                                { xAxis: resampledData[zoneEndIndex].date }
                            ]);
                        }
                    }
                }
            }

            // === MACD D-M è²·è³£é»æª¢æ¸¬ï¼ˆåŸºæ–¼é–¥å€¼ï¼‰===
            const buySellMarkers = { buy: [], sell: [] };
            const dmValues = macdResult.dm;

            let lastTrend = null; // 'decreasing' æˆ– 'increasing' æˆ– null

            for (let i = 1; i < dmValues.length; i++) {
                const prevDM = dmValues[i - 1];
                const currDM = dmValues[i];

                // ç¢ºä¿å€¼å­˜åœ¨
                if (prevDM !== null && currDM !== null) {
                    let currentTrend = null;

                    // åˆ¤æ–·ç•¶å‰è¶¨å‹¢
                    if (currDM > prevDM) {
                        currentTrend = 'increasing'; // å‘ä¸Šï¼ˆè² å‘æ¸›å°‘æˆ–æ­£å‘å¢åŠ ï¼‰
                    } else if (currDM < prevDM) {
                        currentTrend = 'decreasing'; // å‘ä¸‹ï¼ˆè² å‘å¢åŠ æˆ–æ­£å‘æ¸›å°‘ï¼‰
                    }

                    // æª¢æ¸¬è¶¨å‹¢åè½‰
                    if (lastTrend !== null && currentTrend !== null && lastTrend !== currentTrend) {
                        // è¶¨å‹¢æ”¹è®Šäº†
                        if (currentTrend === 'increasing' && prevDM < 0) {
                            // å¾å‘ä¸‹è½‰ç‚ºå‘ä¸Šï¼Œä¸”åœ¨è² å€¼å€åŸŸ
                            // æª¢æŸ¥æ˜¯å¦ç¬¦åˆè²·é»æ¢ä»¶
                            // D-Mè² å€¼åè½‰å¾Œä½æ–¼è²·é»é–¾å€¼ -> è²·é»ï¼ˆå¢¨ç¶ è‰²ï¼‰
                            if (currDM < zoneMarkingState.macdBuySell.buyThreshold) {
                                buySellMarkers.buy.push([
                                    i,
                                    resampledData[i].close,
                                    resampledData[i].date,
                                    resampledData[i].close,
                                    currDM.toFixed(2)
                                ]);
                            }
                        } else if (currentTrend === 'decreasing' && prevDM > 0) {
                            // å¾å‘ä¸Šè½‰ç‚ºå‘ä¸‹ï¼Œä¸”åœ¨æ­£å€¼å€åŸŸ
                            // æª¢æŸ¥æ˜¯å¦ç¬¦åˆè³£é»æ¢ä»¶
                            // D-Mæ­£å€¼åè½‰å¾Œé«˜æ–¼è³£é»é–¾å€¼ -> è³£é»ï¼ˆæ·±ç´…è‰²ï¼‰
                            if (currDM > zoneMarkingState.macdBuySell.sellThreshold) {
                                buySellMarkers.sell.push([
                                    i,
                                    resampledData[i].close,
                                    resampledData[i].date,
                                    resampledData[i].close,
                                    currDM.toFixed(2)
                                ]);
                            }
                        }
                    }

                    // æ›´æ–°è¶¨å‹¢ç‹€æ…‹
                    if (currentTrend !== null) {
                        lastTrend = currentTrend;
                    }
                }
            }

            // é™¤éŒ¯æ—¥èªŒ
            console.log('ğŸ“Š å€åŸŸæ¨™è¨˜çµ±è¨ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            console.log(`  ğŸ”´ è¤‡åˆä½æª”å€: ${compositeMarkAreas.length} å€‹`);
            console.log(`  ğŸŸ¡ KD ä½æª”å€: ${kdMarkAreas.length} å€‹`);
            console.log(`  ğŸŸ£ RSI ä½æª”å€: ${rsiMarkAreas.length} å€‹`);
            console.log(`  ğŸ”µ MACD ä½æª”å€: ${macdMarkAreas.length} å€‹`);
            console.log(`  ğŸ¯ åå½ˆæ¨™è¨˜é»: ${postZoneMarkers.data.length} å€‹`);
            console.log(`  ğŸ”º è¤‡åˆé«˜æª”å€: ${highCompositeMarkAreas.length} å€‹`);
            console.log(`  ğŸŸ  KD é«˜æª”å€: ${highKdMarkAreas.length} å€‹`);
            console.log(`  ğŸ”´ RSI é«˜æª”å€: ${highRsiMarkAreas.length} å€‹`);
            console.log(`  ğŸŸ¥ MACD é«˜æª”å€: ${highMacdMarkAreas.length} å€‹`);
            console.log(`  ğŸŸ£ é«˜æª”å¾Œæ¨™è¨˜é»: ${highPostZoneMarkers.data.length} å€‹`);
            console.log(`  ğŸ”´ è²·é»æ¨™è¨˜: ${buySellMarkers.buy.length} å€‹`);
            console.log(`  ğŸŸ¢ è³£é»æ¨™è¨˜: ${buySellMarkers.sell.length} å€‹`);
            console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

            return {
                kd: { data: kdMarkAreas, lines: kdMarkLines },
                rsi: { data: rsiMarkAreas, lines: rsiMarkLines },
                macd: { data: macdMarkAreas, lines: macdMarkLines },
                composite: { data: compositeMarkAreas, lines: compositeMarkLines },
                postZoneMarkers,
                highPostZoneMarkers,  // é«˜æª”å€å¾Œçš„æ¨™è¨˜é»
                buySellMarkers,       // è²·è³£é»æ¨™è¨˜
                // é«˜æª”å€åŸŸæ¨™è¨˜
                highKd: { data: highKdMarkAreas, lines: highKdMarkLines },
                highRsi: { data: highRsiMarkAreas, lines: highRsiMarkLines },
                highMacd: { data: highMacdMarkAreas, lines: highMacdMarkLines },
                highComposite: { data: highCompositeMarkAreas, lines: highCompositeMarkLines }
            };
        }

        function updateChart(periodType) {
            console.time(`UpdateChart-${periodType}`);
            lastClickedIndex = null; // é‡ç½®é»æ“Šç‹€æ…‹
            currentPeriod = periodType;

            controlButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === periodType);
            });

            statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šæ­£åœ¨å°‡ ${dailyData.length.toLocaleString()} ç­†æ—¥Kè½‰æ›ç‚º ${periodType} è³‡æ–™...`;
            console.time(`Resample-${periodType}`);
            const resampledData = DataService.resampleToPeriod(dailyData, periodType);
            console.timeEnd(`Resample-${periodType}`);

            const closePrices = resampledData.map(item => item.close);
            const macdResult = TechUtils.calculateMACD(closePrices);
            const kdResult = TechUtils.calculateKD(resampledData);
            const rsi5 = TechUtils.calculateRSI(closePrices, 5);  // å¿«ç·š (ä¸€é€±)
            const rsi10 = TechUtils.calculateRSI(closePrices, 10); // æ…¢ç·š (å…©é€±)
            const ma5 = TechUtils.calculateSMA(closePrices, 5);
            const ma10 = TechUtils.calculateSMA(closePrices, 10);
            const ma20 = TechUtils.calculateSMA(closePrices, 20);
            const ma60 = TechUtils.calculateSMA(closePrices, 60);

            const periodMap = { 'daily': 'æ—¥ç·š', 'weekly': 'å‘¨ç·š', 'bi-weekly': 'é›™å‘¨ç·š', 'tri-weekly': 'ä¸‰å‘¨ç·š', 'monthly': 'æœˆç·š' };
            const periodName = periodMap[periodType];

            // å„²å­˜ç•¶å‰åœ–è¡¨æ•¸æ“šä¾›æ¨™è¨˜æ›´æ–°ä½¿ç”¨
            currentChartData = {
                resampledData,
                kdResult,
                rsi5,
                macdResult,
                periodName: periodName
            };

            // ç”Ÿæˆæ¨™è¨˜å€åŸŸ
            const markAreas = generateMarkAreas(currentChartData);
            console.log('âœ… markAreas.postZoneMarkers:', markAreas.postZoneMarkers);
            console.log('âœ… markAreas.highPostZoneMarkers:', markAreas.highPostZoneMarkers);

            chartTitleEl.innerHTML = `ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬ (Beta ç‰ˆ) <span class="badge">Real Data</span>`;

            statusEl.innerHTML = `
                çµ±è¨ˆç¯„åœï¼š<b>${dailyData[0].date}</b> è‡³ <b>${dailyData[dailyData.length-1].date}</b><br>
                åŸå§‹æ—¥Kï¼š${dailyData.length.toLocaleString()} ç­† |
                èšåˆ${periodName}ï¼š${resampledData.length.toLocaleString()} ç­†
            `;

            // å‹•æ…‹è¨ˆç®—ç¶²æ ¼å¸ƒå±€
            const visibleIndicators = [];
            if (indicatorVisible.macd) visibleIndicators.push('macd');
            if (indicatorVisible.kd) visibleIndicators.push('kd');
            if (indicatorVisible.rsi) visibleIndicators.push('rsi');

            const indicatorCount = visibleIndicators.length;
            const indicatorHeight = 11.5; // æ¯å€‹æŒ‡æ¨™é«˜åº¦ç™¾åˆ†æ¯”
            const spacingBetweenCharts = 2.5; // åœ–è¡¨ä¹‹é–“çš„é–“è·ç™¾åˆ†æ¯”
            const totalSpacing = indicatorCount > 0 ? indicatorCount * spacingBetweenCharts : 0;
            const kLineHeight = 86 - (indicatorCount * indicatorHeight) - totalSpacing - 3; // Kç·šåœ–é«˜åº¦(ç•™3%çµ¦dataZoom)

            // å»ºç«‹ç¶²æ ¼é…ç½®
            const grids = [{ left: '80px', right: '5%', top: '12%', height: `${kLineHeight}%` }];
            const titles = [
                { text: `å°ç£åŠ æ¬ŠæŒ‡æ•¸ (${periodName})`, left: 'center', top: 0 },
                { text: 'Kç·š', left: '90px', top: '12%', textStyle: { fontSize: 14, fontWeight: 'bold', color: '#333' } }
            ];

            let currentTop = 12 + kLineHeight + spacingBetweenCharts; // ç•¶å‰ä½ç½®
            let gridIndex = 1;
            const xAxisConfigs = [{ type: 'category', data: resampledData.map(d => d.date), axisLabel: { show: false } }];
            const yAxisConfigs = [{
                scale: true,
                splitLine: { show: true, lineStyle: { color: '#eee' } },
                axisLabel: {
                    formatter: function(value) {
                        return value.toLocaleString();
                    }
                }
            }];
            const xAxisIndices = [0];

            visibleIndicators.forEach((indicator, idx) => {
                grids.push({ left: '80px', right: '5%', top: `${currentTop}%`, height: `${indicatorHeight}%` });
                titles.push({ text: indicator.toUpperCase(), left: '90px', top: `${currentTop}%`, textStyle: { fontSize: 14, fontWeight: 'bold', color: '#333' } });
                xAxisConfigs.push({ type: 'category', gridIndex: gridIndex, data: resampledData.map(d => d.date), axisLabel: { show: false } });
                xAxisIndices.push(gridIndex);

                if (indicator === 'macd') {
                    yAxisConfigs.push({ scale: true, gridIndex: gridIndex, splitLine: { show: false } });
                } else {
                    yAxisConfigs.push({ scale: true, gridIndex: gridIndex, min: 0, max: 100, splitLine: { show: true, lineStyle: { color: '#eee' } } });
                }

                currentTop += indicatorHeight + spacingBetweenCharts;
                gridIndex++;
            });

            // å»ºç«‹ç³»åˆ—æ•¸æ“š
            const series = [
                {
                    name: periodName, type: 'candlestick', data: resampledData.map(d => d.values),
                    itemStyle: { color: '#eb5454', color0: '#47b262', borderColor: '#eb5454', borderColor0: '#47b262' },
                    large: true,
                    markArea: {
                        data: [...markAreas.composite.data, ...markAreas.highComposite.data]
                    },
                    markLine: {
                        data: [...markAreas.composite.lines, ...markAreas.highComposite.lines],
                        symbol: 'none',
                        label: { show: false }
                    },
                    z: 5
                },
                {
                    name: 'ä½æª”åå½ˆæ”¶ç›¤',
                    type: 'scatter',
                    data: markAreas.postZoneMarkers.data,
                    symbolSize: 16,
                    itemStyle: {
                        color: '#ff6600',
                        borderColor: '#fff',
                        borderWidth: 2.5,
                        shadowBlur: 4,
                        shadowColor: 'rgba(255, 102, 0, 0.5)'
                    },
                    emphasis: {
                        scale: 1.4,
                        itemStyle: {
                            color: '#ff4400',
                            shadowBlur: 8,
                            shadowColor: 'rgba(255, 68, 0, 0.8)'
                        }
                    },
                    label: {
                        show: true,
                        position: 'top',
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            return closePrice.toLocaleString();
                        },
                        fontSize: 11,
                        fontWeight: 'bold',
                        color: '#ff6600',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        padding: [3, 6],
                        borderRadius: 3,
                        borderColor: '#ff6600',
                        borderWidth: 1
                    },
                    tooltip: {
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            const date = params.value[2];
                            return `<strong>ä½æª”åå½ˆæ”¶ç›¤</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}`;
                        }
                    },
                    z: 10
                },
                {
                    name: 'é«˜æª”å›è½æ”¶ç›¤',
                    type: 'scatter',
                    data: markAreas.highPostZoneMarkers.data,
                    symbolSize: 16,
                    itemStyle: {
                        color: '#9b59b6',
                        borderColor: '#fff',
                        borderWidth: 2.5,
                        shadowBlur: 4,
                        shadowColor: 'rgba(155, 89, 182, 0.5)'
                    },
                    emphasis: {
                        scale: 1.4,
                        itemStyle: {
                            color: '#8e44ad',
                            shadowBlur: 8,
                            shadowColor: 'rgba(142, 68, 173, 0.8)'
                        }
                    },
                    label: {
                        show: true,
                        position: 'bottom',
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            return closePrice.toLocaleString();
                        },
                        fontSize: 11,
                        fontWeight: 'bold',
                        color: '#9b59b6',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        padding: [3, 6],
                        borderRadius: 3,
                        borderColor: '#9b59b6',
                        borderWidth: 1
                    },
                    tooltip: {
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            const date = params.value[2];
                            return `<strong>é«˜æª”å›è½æ”¶ç›¤</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}`;
                        }
                    },
                    z: 10
                },
                {
                    name: 'è²·é»',
                    type: 'scatter',
                    data: (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.buyEnabled)
                        ? markAreas.buySellMarkers.buy : [],
                    symbolSize: 14,
                    itemStyle: {
                        color: '#1a5f1a',  // å¢¨ç¶ è‰²
                        borderColor: '#fff',
                        borderWidth: 2.5,
                        shadowBlur: 4,
                        shadowColor: 'rgba(26, 95, 26, 0.6)'
                    },
                    emphasis: {
                        scale: 1.4,
                        itemStyle: {
                            color: '#0f4f0f',
                            shadowBlur: 8,
                            shadowColor: 'rgba(26, 95, 26, 0.9)'
                        }
                    },
                    label: {
                        show: true,
                        position: 'top',
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            return `${closePrice.toLocaleString()}`;
                        },
                        fontSize: 10,
                        fontWeight: 'bold',
                        color: '#1a5f1a',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        padding: [3, 6],
                        borderRadius: 3,
                        borderColor: '#1a5f1a',
                        borderWidth: 1.5
                    },
                    tooltip: {
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            const date = params.value[2];
                            const dmValue = params.value[4];
                            return `<strong style="color: #1a5f1a;">ä½é»</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}<br/>D-M: ${dmValue}`;
                        }
                    },
                    z: 12
                },
                {
                    name: 'è³£é»',
                    type: 'scatter',
                    data: (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.sellEnabled)
                        ? markAreas.buySellMarkers.sell : [],
                    symbolSize: 14,
                    itemStyle: {
                        color: '#8b0000',  // æ·±ç´…è‰²
                        borderColor: '#fff',
                        borderWidth: 2.5,
                        shadowBlur: 4,
                        shadowColor: 'rgba(139, 0, 0, 0.6)'
                    },
                    emphasis: {
                        scale: 1.4,
                        itemStyle: {
                            color: '#a00000',
                            shadowBlur: 8,
                            shadowColor: 'rgba(139, 0, 0, 0.9)'
                        }
                    },
                    label: {
                        show: true,
                        position: 'bottom',
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            return `${closePrice.toLocaleString()}`;
                        },
                        fontSize: 10,
                        fontWeight: 'bold',
                        color: '#8b0000',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        padding: [3, 6],
                        borderRadius: 3,
                        borderColor: '#8b0000',
                        borderWidth: 1.5
                    },
                    tooltip: {
                        formatter: (params) => {
                            const closePrice = params.value[1];
                            const date = params.value[2];
                            const dmValue = params.value[4];
                            return `<strong style="color: #8b0000;">é«˜é»</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}<br/>D-M: ${dmValue}`;
                        }
                    },
                    z: 12
                },
                { name: 'MA5', type: 'line', data: ma5, smooth: true, lineStyle: { width: 1.5, color: '#FFBF00' }, symbol: 'none' },
                { name: 'MA10', type: 'line', data: ma10, smooth: true, lineStyle: { width: 1.5, color: '#8A2BE2' }, symbol: 'none' },
                { name: 'MA20', type: 'line', data: ma20, smooth: true, lineStyle: { width: 1.5, color: '#32CD32' }, symbol: 'none' },
                { name: 'MA60', type: 'line', data: ma60, smooth: true, lineStyle: { width: 1.5, color: '#FF1493' }, symbol: 'none' }
            ];

            const legendData = [
                { name: 'MA5', itemStyle: { color: '#FFBF00' } },
                { name: 'MA10', itemStyle: { color: '#8A2BE2' } },
                { name: 'MA20', itemStyle: { color: '#32CD32' } },
                { name: 'MA60', itemStyle: { color: '#FF1493' } }
            ];

            // æ ¹æ“šå¯è¦‹æ€§æ·»åŠ æŒ‡æ¨™ç³»åˆ—
            visibleIndicators.forEach((indicator, idx) => {
                const axisIndex = idx + 1;

                if (indicator === 'macd') {
                    legendData.push(
                        { name: 'DIF', itemStyle: { color: '#DA6EE8' } },
                        { name: 'MACD', itemStyle: { color: '#00D5FA' } }
                    );
                    series.push(
                        {
                            name: 'DIF', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: macdResult.dif, lineStyle: { color: '#DA6EE8', width: 1.5 }, symbol: 'none',
                            markArea: { data: [...markAreas.macd.data, ...markAreas.highMacd.data] },
                            markLine: { data: [...markAreas.macd.lines, ...markAreas.highMacd.lines], symbol: 'none', label: { show: false } }
                        },
                        { name: 'MACD', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.macd, lineStyle: { color: '#00D5FA', width: 1.5 }, symbol: 'none' },
                        { name: 'D-M', type: 'bar', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.dm, itemStyle: { color: (p) => p.value > 0 ? '#eb5454' : '#47b262' } }
                    );
                } else if (indicator === 'kd') {
                    legendData.push(
                        { name: 'K(9)', itemStyle: { color: '#FF6B6B' } },
                        { name: 'D(9)', itemStyle: { color: '#4ECDC4' } }
                    );
                    series.push(
                        {
                            name: 'K(9)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: kdResult.k, lineStyle: { color: '#FF6B6B', width: 1.5 }, symbol: 'none',
                            markArea: { data: [...markAreas.kd.data, ...markAreas.highKd.data] },
                            markLine: { data: [...markAreas.kd.lines, ...markAreas.highKd.lines], symbol: 'none', label: { show: false } }
                        },
                        { name: 'D(9)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: kdResult.d, lineStyle: { color: '#4ECDC4', width: 1.5 }, symbol: 'none' },
                        {
                            name: 'KDè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(80),
                            lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'KDè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(20),
                            lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        }
                    );
                } else if (indicator === 'rsi') {
                    legendData.push(
                        { name: 'RSI(5T)', itemStyle: { color: '#FF8C00' } },
                        { name: 'RSI(10T)', itemStyle: { color: '#9370DB' } }
                    );
                    series.push(
                        {
                            name: 'RSI(5T)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: rsi5, lineStyle: { color: '#FF8C00', width: 2 }, symbol: 'none',
                            markArea: { data: [...markAreas.rsi.data, ...markAreas.highRsi.data] },
                            markLine: { data: [...markAreas.rsi.lines, ...markAreas.highRsi.lines], symbol: 'none', label: { show: false } }
                        },
                        { name: 'RSI(10T)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: rsi10, lineStyle: { color: '#9370DB', width: 2 }, symbol: 'none' },
                        {
                            name: 'RSIè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(80),
                            lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'RSIè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(20),
                            lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'RSIä¸­ç·š', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(50),
                            lineStyle: { color: '#999', width: 1, type: 'dotted' },
                            symbol: 'none', silent: true, animation: false
                        }
                    );
                }
            });

            // ç‚ºæ¯å€‹ç¶²æ ¼æ·»åŠ ä¸€å€‹ç”¨æ–¼åå­—ç·šçš„ç³»åˆ—
            grids.forEach((grid, idx) => {
                series.push({
                    name: `crosshair-${idx}`,
                    type: 'line',
                    xAxisIndex: idx,
                    yAxisIndex: idx,
                    data: [],
                    markLine: {
                        silent: true,
                        animation: false,
                        symbol: ['none', 'none'],
                        data: []
                    }
                });
            });

            const option = {
                title: titles,
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                axisPointer: { link: { xAxisIndex: 'all' } },
                legend: {
                    top: 30,
                    data: legendData
                },
                grid: grids,
                xAxis: xAxisConfigs,
                yAxis: yAxisConfigs,
                dataZoom: [
                    { type: 'inside', xAxisIndex: xAxisIndices, start: 95, end: 100 },
                    { type: 'slider', xAxisIndex: xAxisIndices, top: '97%', start: 95, end: 100 }
                ],
                series: series
            };

            myChart.setOption(option, true);
            console.timeEnd(`UpdateChart-${periodType}`);
        }

        controlButtons.forEach(button => {
            button.addEventListener('click', () => {
                const period = button.dataset.period;
                if (period && period !== currentPeriod) {
                    // é‡ç½®æ¨è–¦é…ç½®ä¸‹æ‹‰é¸å–®ç‚ºé è¨­å€¼
                    const configDropdown = document.getElementById('configDropdown');
                    configDropdown.value = '';

                    // éš±è—æ³¨æ„äº‹é …
                    const configNotes = document.getElementById('configNotes');
                    configNotes.classList.add('hidden');

                    updateChart(period);
                }
            });
        });

        // æŒ‡æ¨™é–‹é—œæŒ‰éˆ•
        const indicatorCheckboxes = document.querySelectorAll('.indicator-checkbox input[type="checkbox"]');
        indicatorCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const indicator = checkbox.dataset.indicator;
                indicatorVisible[indicator] = checkbox.checked;

                // åŒæ­¥æ›´æ–°æ§åˆ¶é¢æ¿ä¸­çš„è¤‡åˆæ¨™è¨˜é¸é …å’Œè¨­å®šå€å¡Š
                if (indicator === 'kd') {
                    compositeKD.checked = checkbox.checked;
                    compositeKD.disabled = !checkbox.checked;
                    zoneMarkingState.composite.useKD = checkbox.checked;
                    // æ§åˆ¶ KD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                    if (checkbox.checked) {
                        kdPanelSection.classList.remove('hidden');
                    } else {
                        kdPanelSection.classList.add('hidden');
                    }
                } else if (indicator === 'rsi') {
                    compositeRSI.checked = checkbox.checked;
                    compositeRSI.disabled = !checkbox.checked;
                    zoneMarkingState.composite.useRSI = checkbox.checked;
                    // æ§åˆ¶ RSI è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                    if (checkbox.checked) {
                        rsiPanelSection.classList.remove('hidden');
                    } else {
                        rsiPanelSection.classList.add('hidden');
                    }
                } else if (indicator === 'macd') {
                    compositeMACD.checked = checkbox.checked;
                    compositeMACD.disabled = !checkbox.checked;
                    zoneMarkingState.composite.useMACD = checkbox.checked;
                    // æ§åˆ¶ MACD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                    if (checkbox.checked) {
                        macdPanelSection.classList.remove('hidden');
                    } else {
                        macdPanelSection.classList.add('hidden');
                    }
                }

                toggleIndicatorVisibility();
            });
        });

        // é…ç½®é è¨­ç®¡ç†
        const configPresets = {
            easyMonthly: {
                name: 'è¼•é¬†æœˆæ”¾',
                period: 'monthly',
                notes: [
                    'åŸå‰‡ä¸Šåœ¨ç¶ è‰²é»å‡ºç¾æ™‚è²·é€²ã€ç´«è‰²é»å‡ºç¾æ™‚è³£å‡º',
                    'è‹¥ç¶ è‰²é»è·Œç ´ç›¤æ•´ä¹Ÿè¦è‡ªè¡Œè³£å‡º',
                    'è‹¥æƒ³æœ€å¤§åŒ–æ”¶ç›Šï¼Œå¯å¾è‡ªè¡Œé æ¸¬ç¶ é»çš„å‡ºç¾ä¾†ææ—©è²·åœ¨è°·åº•'
                ],
                macdBuySell: {
                    masterEnabled: true,
                    sellEnabled: false,
                    buyEnabled: true,
                    sellThreshold: 0,
                    buyThreshold: 0
                },
                masterEnabled: false,
                composite: {
                    useMACD: false,
                    useKD: false,
                    useRSI: false
                },
                highMasterEnabled: true,
                highMacd: {
                    enabled: true,
                    threshold: 400
                },
                highKd: {
                    enabled: true,
                    threshold: 76
                },
                highComposite: {
                    useMACD: true,
                    useKD: true,
                    useRSI: false
                }
            }
        };

        // æ‡‰ç”¨é…ç½®
        function applyConfiguration(configKey) {
            if (!configKey || !configPresets[configKey]) return;

            const config = configPresets[configKey];

            // è¨˜éŒ„æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“åœ–è¡¨
            const needFullUpdate = config.period && config.period !== currentPeriod;

            // ========== å…ˆæ›´æ–°æ‰€æœ‰ç‹€æ…‹ï¼Œå†æ¸²æŸ“åœ–è¡¨ ==========

            // 1. è¨­å®šMACDè²·è³£é»æ¨™è¨˜ï¼ˆé«˜é»é–¥å€¼å’Œä½é»é–¥å€¼ï¼‰
            if (config.macdBuySell) {
                const macdBuySellMasterToggle = document.getElementById('macdBuySellMasterToggle');
                const macdSellToggle = document.getElementById('macdSellToggle');
                const macdBuyToggle = document.getElementById('macdBuyToggle');
                const macdSellThreshold = document.getElementById('macdSellThreshold');
                const macdSellThresholdRange = document.getElementById('macdSellThresholdRange');
                const macdBuyThreshold = document.getElementById('macdBuyThreshold');
                const macdBuyThresholdRange = document.getElementById('macdBuyThresholdRange');

                // è¨­å®šç¸½é–‹é—œ
                if (config.macdBuySell.masterEnabled !== undefined) {
                    macdBuySellMasterToggle.checked = config.macdBuySell.masterEnabled;
                    zoneMarkingState.macdBuySell.masterEnabled = config.macdBuySell.masterEnabled;
                }

                macdSellToggle.checked = config.macdBuySell.sellEnabled;
                zoneMarkingState.macdBuySell.sellEnabled = config.macdBuySell.sellEnabled;

                macdBuyToggle.checked = config.macdBuySell.buyEnabled;
                zoneMarkingState.macdBuySell.buyEnabled = config.macdBuySell.buyEnabled;

                macdSellThreshold.value = config.macdBuySell.sellThreshold;
                macdSellThresholdRange.value = config.macdBuySell.sellThreshold;
                zoneMarkingState.macdBuySell.sellThreshold = config.macdBuySell.sellThreshold;

                macdBuyThreshold.value = config.macdBuySell.buyThreshold;
                macdBuyThresholdRange.value = config.macdBuySell.buyThreshold;
                zoneMarkingState.macdBuySell.buyThreshold = config.macdBuySell.buyThreshold;
            }

            // 2. è¨­å®šé«˜æª”å€åŸŸæ¨™è¨˜
            const highMasterToggle = document.getElementById('highMasterToggle');
            highMasterToggle.checked = config.highMasterEnabled !== undefined ? config.highMasterEnabled : false;
            zoneMarkingState.highMasterEnabled = highMasterToggle.checked;

            if (config.highMacd) {
                const highMacdThreshold = document.getElementById('highMacdThreshold');
                const highMacdThresholdRange = document.getElementById('highMacdThresholdRange');
                highMacdThreshold.value = config.highMacd.threshold;
                highMacdThresholdRange.value = config.highMacd.threshold;
                zoneMarkingState.highMacd.threshold = config.highMacd.threshold;
            }

            if (config.highKd) {
                const highKdThreshold = document.getElementById('highKdThreshold');
                const highKdThresholdRange = document.getElementById('highKdThresholdRange');
                highKdThreshold.value = config.highKd.threshold;
                highKdThresholdRange.value = config.highKd.threshold;
                zoneMarkingState.highKd.threshold = config.highKd.threshold;
            }

            if (config.highRsi) {
                const highRsiThreshold = document.getElementById('highRsiThreshold');
                const highRsiThresholdRange = document.getElementById('highRsiThresholdRange');
                highRsiThreshold.value = config.highRsi.threshold;
                highRsiThresholdRange.value = config.highRsi.threshold;
                zoneMarkingState.highRsi.threshold = config.highRsi.threshold;
            }

            if (config.highComposite) {
                const highCompositeMACD = document.getElementById('highCompositeMACD');
                const highCompositeKD = document.getElementById('highCompositeKD');
                const highCompositeRSI = document.getElementById('highCompositeRSI');

                const highMacdPanelSection = document.getElementById('highMacdSection');
                const highKdPanelSection = document.getElementById('highKdSection');
                const highRsiPanelSection = document.getElementById('highRsiSection');

                highCompositeMACD.checked = config.highComposite.useMACD;
                zoneMarkingState.highComposite.useMACD = config.highComposite.useMACD;
                if (config.highComposite.useMACD) {
                    highMacdPanelSection.classList.remove('hidden');
                } else {
                    highMacdPanelSection.classList.add('hidden');
                }

                highCompositeKD.checked = config.highComposite.useKD;
                zoneMarkingState.highComposite.useKD = config.highComposite.useKD;
                if (config.highComposite.useKD) {
                    highKdPanelSection.classList.remove('hidden');
                } else {
                    highKdPanelSection.classList.add('hidden');
                }

                highCompositeRSI.checked = config.highComposite.useRSI;
                zoneMarkingState.highComposite.useRSI = config.highComposite.useRSI;
                if (config.highComposite.useRSI) {
                    highRsiPanelSection.classList.remove('hidden');
                } else {
                    highRsiPanelSection.classList.add('hidden');
                }
            }

            // 3. è¨­å®šä½æª”å€åŸŸæ¨™è¨˜
            const masterToggle = document.getElementById('masterToggle');
            masterToggle.checked = config.masterEnabled !== undefined ? config.masterEnabled : false;
            zoneMarkingState.masterEnabled = masterToggle.checked;

            // 4. è¨­å®šä½æª”å€åŸŸè¤‡åˆæ¢ä»¶
            if (config.composite) {
                const compositeMACD = document.getElementById('compositeMACD');
                const compositeKD = document.getElementById('compositeKD');
                const compositeRSI = document.getElementById('compositeRSI');

                const lowMacdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="macd"]');
                const lowKdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="kd"]');
                const lowRsiPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="rsi"]');

                compositeMACD.checked = config.composite.useMACD;
                zoneMarkingState.composite.useMACD = config.composite.useMACD;
                if (config.composite.useMACD) {
                    lowMacdPanelSection.classList.remove('hidden');
                } else {
                    lowMacdPanelSection.classList.add('hidden');
                }

                compositeKD.checked = config.composite.useKD;
                zoneMarkingState.composite.useKD = config.composite.useKD;
                if (config.composite.useKD) {
                    lowKdPanelSection.classList.remove('hidden');
                } else {
                    lowKdPanelSection.classList.add('hidden');
                }

                compositeRSI.checked = config.composite.useRSI;
                zoneMarkingState.composite.useRSI = config.composite.useRSI;
                if (config.composite.useRSI) {
                    lowRsiPanelSection.classList.remove('hidden');
                } else {
                    lowRsiPanelSection.classList.add('hidden');
                }
            }

            // ========== æ‰€æœ‰ç‹€æ…‹æ›´æ–°å®Œç•¢ï¼Œç¾åœ¨æ›´æ–°åœ–è¡¨ ==========

            // å¦‚æœé€±æœŸæ”¹è®Šï¼Œå®Œæ•´æ¸²æŸ“åœ–è¡¨
            if (needFullUpdate) {
                updateChart(config.period);
            } else {
                // é€±æœŸæœªæ”¹è®Šï¼Œåªæ›´æ–°æ¨™è¨˜
                updateChartMarkingsOnly();
            }
        }

        // é…ç½®ä¸‹æ‹‰é¸å–®äº‹ä»¶ç›£è½
        const configDropdown = document.getElementById('configDropdown');
        const configNotes = document.getElementById('configNotes');
        const configNotesList = document.getElementById('configNotesList');

        configDropdown.addEventListener('change', (e) => {
            const selectedConfig = e.target.value;
            if (selectedConfig) {
                applyConfiguration(selectedConfig);

                // é¡¯ç¤ºæ³¨æ„äº‹é …
                const config = configPresets[selectedConfig];
                if (config && config.notes && config.notes.length > 0) {
                    configNotesList.innerHTML = '';
                    config.notes.forEach(note => {
                        const li = document.createElement('li');
                        li.textContent = note;
                        configNotesList.appendChild(li);
                    });
                    configNotes.classList.remove('hidden');
                } else {
                    configNotes.classList.add('hidden');
                }
            } else {
                // æ¸…é™¤é¸æ“‡æ™‚éš±è—æ³¨æ„äº‹é …
                configNotes.classList.add('hidden');
            }
        });

        updateChart(currentPeriod);

        myChart.getZr().on('click', function (event) {
            const pointInPixel = [event.offsetX, event.offsetY];
            let dataIndex = null;
            let clickedGridIndex = -1;

            // æŸ¥æ‰¾è¢«é»æ“Šçš„ç¶²æ ¼
            const grids = myChart.getOption().grid;
            for (let i = 0; i < grids.length; i++) {
                if (myChart.containPixel({ gridIndex: i }, pointInPixel)) {
                    clickedGridIndex = i;
                    break;
                }
            }

            if (clickedGridIndex !== -1) {
                // å°‡åƒç´ åº§æ¨™è½‰æ›ç‚ºé‚è¼¯åº§æ¨™ (å–å¾— dataIndex)
                const pointInGrid = myChart.convertFromPixel({ gridIndex: clickedGridIndex }, pointInPixel);
                dataIndex = pointInGrid[0];
            }

            let hLine, vLine;
            let seriesUpdate = [];

            // æª¢æŸ¥æ˜¯å¦é»æ“Šäº†æœ‰æ•ˆçš„è³‡æ–™é»
            if (dataIndex != null && currentChartData && dataIndex >= 0 && dataIndex < currentChartData.resampledData.length) {
                if (lastClickedIndex === dataIndex) {
                    // å†æ¬¡é»æ“ŠåŒä¸€å€‹ä½ç½®ï¼Œå–æ¶ˆåå­—ç·š
                    lastClickedIndex = null;
                } else {
                    // é»æ“Šæ–°ä½ç½®ï¼Œè¨­å®šåå­—ç·š
                    lastClickedIndex = dataIndex;
                }
            } else {
                // é»æ“Šåœ–è¡¨ç¶²æ ¼å¤–ï¼Œå–æ¶ˆåå­—ç·š
                lastClickedIndex = null;
            }

            // æ ¹æ“š lastClickedIndex çš„ç‹€æ…‹æº–å‚™æ¨™è¨˜ç·šæ•¸æ“š
            if (lastClickedIndex !== null) {
                const clickedData = currentChartData.resampledData[lastClickedIndex];
                const closePrice = clickedData.close;
                const date = clickedData.date;

                // æ°´å¹³ç·š
                hLine = {
                    yAxis: closePrice,
                    lineStyle: { color: '#2f3e4d', type: 'solid', width: 1 },
                    label: {
                        show: true,
                        position: 'start', // é¡¯ç¤ºåœ¨å·¦å´
                        formatter: closePrice.toLocaleString(),
                        color: '#fff',
                        backgroundColor: '#2f3e4d',
                        padding: [4, 8],
                        borderRadius: 4,
                        fontSize: 12,
                    }
                };

                // å‚ç›´ç·š
                vLine = {
                    xAxis: date,
                    lineStyle: { color: '#2f3e4d', type: 'solid', width: 1 },
                    label: {
                        show: true,
                        position: 'end',
                        formatter: function() {
                            if (date.includes('~')) {
                                return date.split('~')[0].trim() + '\n' + date.split('~')[1].trim();
                            }
                            return date;
                        },
                        color: '#fff',
                        backgroundColor: '#2f3e4d',
                        padding: [4, 8],
                        borderRadius: 4,
                        fontSize: 12,
                    }
                };
            }

            // æ›´æ–°æ‰€æœ‰åå­—ç·šç³»åˆ—
            const gridCount = myChart.getOption().grid.length;
            for (let i = 0; i < gridCount; i++) {
                let markLineData = [];
                if (lastClickedIndex !== null) {
                    if (i === 0) { // ä¸»åœ–
                        markLineData = [hLine, vLine];
                    } else { // æŒ‡æ¨™åœ–
                        markLineData = [vLine];
                    }
                }
                seriesUpdate.push({
                    name: `crosshair-${i}`,
                    markLine: { data: markLineData }
                });
            }
            
            myChart.setOption({ series: seriesUpdate });
        });

        const clearCrosshairBtn = document.getElementById('clearCrosshairBtn');
        clearCrosshairBtn.addEventListener('click', function() {
            lastClickedIndex = null;
            let seriesUpdate = [];
            const gridCount = myChart.getOption().grid.length;
            for (let i = 0; i < gridCount; i++) {
                seriesUpdate.push({
                    name: `crosshair-${i}`,
                    markLine: { data: [] }
                });
            }
            myChart.setOption({ series: seriesUpdate });
        });

        window.addEventListener('resize', myChart.resize);
    }

    initApp();
</script>

</body>
</html>