<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/weekOfYear.js"></script>

    <style>
        body { font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; margin: 20px; background: #f4f6f8; }
        .card { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
        h2 { margin-top: 0; color: #2c3e50; border-left: 5px solid #3498db; padding-left: 10px; }
        #chart { width: 100%; height: 900px; }
        .status { margin-bottom: 15px; color: #7f8c8d; font-size: 0.95em; font-family: monospace; }
        .badge { background: #28a745; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.8em; margin-left: 10px;}
        .controls { margin-bottom: 20px; }
        .btn {
            background: #e9ecef;
            border: 1px solid #ced4da;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            margin-right: 8px;
            transition: background 0.2s, color 0.2s;
        }
        .btn:hover { background: #d3d9df; }
        .btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        .indicator-checkbox {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 0.95em;
            user-select: none;
        }
        .indicator-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 6px;
            cursor: pointer;
        }
        .control-panel-btn {
            background: #6c757d;
            color: white;
            border: 1px solid #6c757d;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            margin-left: 20px;
            transition: background 0.2s;
        }
        .control-panel-btn:hover { background: #5a6268; }
        .floating-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 300px;
            max-width: 400px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
        }
        .floating-panel::-webkit-scrollbar {
            width: 8px;
        }
        .floating-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .floating-panel::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 4px;
        }
        .floating-panel::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }
        .floating-panel.show { display: block; }
        .floating-panel h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .close-btn:hover { background: #c0392b; }
        .panel-section {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .panel-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        .panel-section input[type="range"] {
            width: 100%;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .panel-section input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .panel-section input[type="range"]::-webkit-slider-thumb:hover {
            background: #2980b9;
        }
        .panel-section input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3498db;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: background 0.2s;
        }
        .panel-section input[type="range"]::-moz-range-thumb:hover {
            background: #2980b9;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-wrapper {
            flex: 1;
            position: relative;
        }
        .slider-limits {
            display: flex;
            justify-content: space-between;
            margin-top: 2px;
            font-size: 0.75em;
            color: #6c757d;
        }
        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #3498db;
            background: #e3f2fd;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.95em;
        }
        .panel-section input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
        }
        .checkbox-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .master-switch {
            background: #28a745;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            text-align: center;
        }
        .master-switch label {
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .master-switch input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .preset-section {
            margin-bottom: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 6px;
        }
        .preset-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #1976d2;
        }
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .preset-btn {
            background: white;
            border: 2px solid #3498db;
            color: #3498db;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s;
        }
        .preset-btn:hover {
            background: #e3f2fd;
        }
        .preset-btn.active {
            background: #3498db;
            color: white;
        }
    </style>
</head>
<body>

<div class="card">
    <h2 id="chart-title">ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ) <span class="badge">Real Data</span></h2>
    <div class="controls">
        <button class="btn active" data-period="daily">æ—¥ç·š</button>
        <button class="btn" data-period="weekly">å‘¨ç·š</button>
        <button class="btn" data-period="bi-weekly">é›™å‘¨ç·š</button>
        <button class="btn" data-period="tri-weekly">ä¸‰å‘¨ç·š</button>
        <button class="btn" data-period="monthly">æœˆç·š</button>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="macd" checked> MACD
        </label>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="kd" checked> KD
        </label>
        <label class="indicator-checkbox">
            <input type="checkbox" data-indicator="rsi" checked> RSI
        </label>
        <button class="control-panel-btn" id="openPanelBtn">âš™ï¸ èª¿æ•´æ¨™è¨˜é–¾å€¼</button>
    </div>
    <div class="status" id="status">ç³»çµ±ç‹€æ…‹ï¼šåˆå§‹åŒ–...</div>
    <div id="chart"></div>
</div>

<div class="floating-panel" id="controlPanel">
    <h3>
        æ¨™è¨˜å€åŸŸæ§åˆ¶
        <button class="close-btn" id="closePanelBtn">âœ•</button>
    </h3>

    <div class="master-switch">
        <label>
            <input type="checkbox" id="masterSwitch" checked>
            å•Ÿç”¨æ‰€æœ‰ä½æª”æ¨™è¨˜
        </label>
    </div>

    <div class="preset-section">
        <label>å¿«é€Ÿé…ç½®</label>
        <div class="preset-buttons">
            <button class="preset-btn active" data-preset="1">é…ç½® 1</button>
            <button class="preset-btn" data-preset="2">é…ç½® 2</button>
            <button class="preset-btn" data-preset="3">é…ç½® 3</button>
            <button class="preset-btn" data-preset="4">é…ç½® 4</button>
        </div>
    </div>

    <div class="panel-section">
        <label>MACD ä½æª”é–¾å€¼</label>
        <div class="slider-container">
            <div class="slider-wrapper">
                <input type="range" id="macdThreshold" value="-185" min="-1000" max="500" step="5">
                <div class="slider-limits">
                    <span>-1000</span>
                    <span>500</span>
                </div>
            </div>
            <span class="slider-value" id="macdValue">-185</span>
        </div>
    </div>

    <div class="panel-section">
        <label>KD ä½æª”é–¾å€¼</label>
        <div class="slider-container">
            <div class="slider-wrapper">
                <input type="range" id="kdThreshold" value="20" min="0" max="80" step="1">
                <div class="slider-limits">
                    <span>0</span>
                    <span>80</span>
                </div>
            </div>
            <span class="slider-value" id="kdValue">20</span>
        </div>
    </div>

    <div class="panel-section">
        <label>RSI ä½æª”é–¾å€¼</label>
        <div class="slider-container">
            <div class="slider-wrapper">
                <input type="range" id="rsiThreshold" value="20" min="0" max="80" step="1">
                <div class="slider-limits">
                    <span>0</span>
                    <span>80</span>
                </div>
            </div>
            <span class="slider-value" id="rsiValue">20</span>
        </div>
    </div>

    <div class="panel-section">
        <label style="margin-bottom: 10px;">Kç·šæ¨™è¨˜æ¡ç”¨æŒ‡æ¨™</label>
        <div class="checkbox-row">
            <input type="checkbox" id="useKdForKline" checked>
            <label style="margin: 0;">ä½¿ç”¨ KD</label>
        </div>
        <div class="checkbox-row">
            <input type="checkbox" id="useMacdForKline" checked>
            <label style="margin: 0;">ä½¿ç”¨ MACD</label>
        </div>
        <div class="checkbox-row">
            <input type="checkbox" id="useRsiForKline" checked>
            <label style="margin: 0;">ä½¿ç”¨ RSI</label>
        </div>
    </div>
</div>

<script>
    // --- 0. è¨­å®š Day.js ---
    dayjs.extend(window.dayjs_plugin_weekOfYear);

    // --- 1. [Utils] æ•¸å­¸è¨ˆç®—å·¥å…· (æ¡ç”¨SMAé ç†±ï¼Œå‘½åèˆ‡æ¨¹ç²¾éˆåŒæ­¥) ---
    const TechUtils = {
        calculateSMA: (data, period) => {
            if (!data || data.length < period) {
                return new Array(data.length).fill(null);
            }
            const smaArray = new Array(data.length).fill(null);
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i];
                if (i >= period) {
                    sum -= data[i - period];
                    smaArray[i] = sum / period;
                } else if (i === period - 1) {
                    smaArray[i] = sum / period;
                }
            }
            return smaArray;
        },

        calculateEMA: (data, period) => {
            if (!data || data.length < period) {
                return new Array(data.length).fill(null);
            }

            const k = 2 / (period + 1);
            const emaArray = new Array(data.length).fill(null);

            let sma = 0;
            for (let i = 0; i < period; i++) {
                sma += data[i];
            }
            emaArray[period - 1] = sma / period;

            for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }

            return emaArray;
        },

        calculateMACD: (closePrices, shortPeriod = 12, longPeriod = 26, midPeriod = 9) => {
            const totalLength = closePrices.length;
            if (totalLength < longPeriod + midPeriod -1) {
                return { dif: [], macd: [], dm: [] };
            }

            const shortEMA = TechUtils.calculateEMA(closePrices, shortPeriod);
            const longEMA = TechUtils.calculateEMA(closePrices, longPeriod);

            const dif = new Array(totalLength).fill(null);
            for (let i = longPeriod - 1; i < totalLength; i++) {
                if (longEMA[i] !== null && shortEMA[i] !== null) {
                     dif[i] = shortEMA[i] - longEMA[i];
                }
            }

            const difValues = dif.slice(longPeriod - 1);
            const macdValues = TechUtils.calculateEMA(difValues, midPeriod);

            const macd = new Array(totalLength).fill(null);
            for (let i = 0; i < macdValues.length; i++) {
                if (macdValues[i] !== null) {
                    macd[i + longPeriod - 1] = macdValues[i];
                }
            }
            
            const dm = new Array(totalLength).fill(null);
            const startIndex = longPeriod - 1 + midPeriod - 1;
            for (let i = startIndex; i < totalLength; i++) {
                 if (dif[i] !== null && macd[i] !== null) {
                    dm[i] = dif[i] - macd[i];
                 }
            }

            return { dif, macd, dm };
        },

        calculateKD: (data, kPeriod = 9, dPeriod = 3) => {
            const totalLength = data.length;
            if (totalLength < kPeriod) {
                return { k: [], d: [] };
            }

            const rsvArray = new Array(totalLength).fill(null);

            for (let i = kPeriod - 1; i < totalLength; i++) {
                let highestHigh = -Infinity;
                let lowestLow = Infinity;

                for (let j = i - kPeriod + 1; j <= i; j++) {
                    if (data[j].high > highestHigh) highestHigh = data[j].high;
                    if (data[j].low < lowestLow) lowestLow = data[j].low;
                }

                const range = highestHigh - lowestLow;
                if (range !== 0) {
                    rsvArray[i] = ((data[i].close - lowestLow) / range) * 100;
                } else {
                    rsvArray[i] = 50;
                }
            }

            const kArray = new Array(totalLength).fill(null);
            kArray[kPeriod - 1] = rsvArray[kPeriod - 1];

            for (let i = kPeriod; i < totalLength; i++) {
                if (rsvArray[i] !== null && kArray[i - 1] !== null) {
                    kArray[i] = (kArray[i - 1] * 2 / 3) + (rsvArray[i] * 1 / 3);
                }
            }

            const dArray = new Array(totalLength).fill(null);
            dArray[kPeriod - 1] = kArray[kPeriod - 1];

            for (let i = kPeriod; i < totalLength; i++) {
                if (kArray[i] !== null && dArray[i - 1] !== null) {
                    dArray[i] = (dArray[i - 1] * 2 / 3) + (kArray[i] * 1 / 3);
                }
            }

            return { k: kArray, d: dArray };
        },

        calculateRSI: (closePrices, period = 14) => {
            const totalLength = closePrices.length;
            if (totalLength < period + 1) {
                return new Array(totalLength).fill(null);
            }

            const rsiArray = new Array(totalLength).fill(null);
            let avgGain = 0;
            let avgLoss = 0;

            for (let i = 1; i <= period; i++) {
                const change = closePrices[i] - closePrices[i - 1];
                if (change > 0) {
                    avgGain += change;
                } else {
                    avgLoss += Math.abs(change);
                }
            }
            avgGain /= period;
            avgLoss /= period;

            if (avgLoss === 0) {
                rsiArray[period] = 100;
            } else {
                const rs = avgGain / avgLoss;
                rsiArray[period] = 100 - (100 / (1 + rs));
            }

            for (let i = period + 1; i < totalLength; i++) {
                const change = closePrices[i] - closePrices[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? Math.abs(change) : 0;

                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;

                if (avgLoss === 0) {
                    rsiArray[i] = 100;
                } else {
                    const rs = avgGain / avgLoss;
                    rsiArray[i] = 100 - (100 / (1 + rs));
                }
            }

            return rsiArray;
        }
    };

    // --- 2. [Service] è³‡æ–™è™•ç†å±¤ (æ”¹ç‚ºä¸²æ¥çœŸå¯¦ API) ---
    const DataService = {
        fetchRealData: async () => {
            const API_URL = 'https://api.finmindtrade.com/api/v4/data?dataset=TaiwanStockPrice&data_id=TAIEX&start_date=1997-01-01';
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                const result = await response.json();
                if (result.data && result.data.length > 0) {
                    return result.data.map(item => ({
                        date: item.date,
                        open: item.open,
                        high: item.max,
                        low: item.min,
                        close: item.close,
                        values: [item.open, item.close, item.min, item.max]
                    }));
                } else {
                    throw new Error('No data received from API');
                }
            } catch (error) {
                console.error("Failed to fetch real data:", error);
                return [];
            }
        },

        resampleToPeriod: (dailyData, periodType) => {
            if (periodType === 'daily') {
                return dailyData.map(d => ({ ...d, date: d.date }));
            }

            const grouped = {};
            dailyData.forEach(tick => {
                const d = dayjs(tick.date);
                let key;
                switch (periodType) {
                    case 'weekly':
                        key = `${d.year()}-W${String(d.week()).padStart(2, '0')}`;
                        break;
                    case 'bi-weekly':
                        const biWeekIndex = Math.floor(d.week() / 2);
                        key = `${d.year()}-BW${String(biWeekIndex).padStart(2, '0')}`;
                        break;
                    case 'tri-weekly':
                        const triWeekIndex = Math.floor(d.week() / 3);
                        key = `${d.year()}-TW${String(triWeekIndex).padStart(2, '0')}`;
                        break;
                    case 'monthly':
                        key = d.format('YYYY-MM');
                        break;
                }

                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(tick);
            });

            return Object.keys(grouped).sort().map(key => {
                const ticks = grouped[key];
                const firstTick = ticks[0];
                const lastTick = ticks[ticks.length - 1];

                const open = firstTick.open;
                const close = lastTick.close;
                const high = Math.max(...ticks.map(t => t.high));
                const low = Math.min(...ticks.map(t => t.low));
                
                const displayDate = `${firstTick.date} ~ ${lastTick.date}`;

                return { 
                    date: displayDate,
                    open, 
                    close, 
                    high, 
                    low, 
                    values: [open, close, low, high] 
                };
            });
        }
    };

    // --- 3. [View] æ¸²æŸ“å±¤ (æ”¹ç‚ºéåŒæ­¥ async function) ---
    async function initApp() {
        const statusEl = document.getElementById('status');
        const chartTitleEl = document.getElementById('chart-title');
        const chartDom = document.getElementById('chart');
        const myChart = echarts.init(chartDom);
        const controlButtons = document.querySelectorAll('.btn');

        statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: #3498db;">æ­£åœ¨å¾ FinMind API ç²å–çœŸå¯¦å°è‚¡åŠ æ¬ŠæŒ‡æ•¸æ­·å²è³‡æ–™...</span>`;

        console.time("FetchRealData");
        const dailyData = await DataService.fetchRealData();
        console.timeEnd("FetchRealData");
        
        if (dailyData.length === 0) {
             statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: red;">ç²å–çœŸå¯¦è³‡æ–™å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚åœ–è¡¨ç„¡æ³•è¼‰å…¥ã€‚</span>`;
             return;
        }

        statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šçœŸå¯¦è³‡æ–™è¼‰å…¥æˆåŠŸï¼Œè«‹é¸æ“‡æ™‚é–“é€±æœŸã€‚`;

        let currentPeriod = 'daily';
        let indicatorVisible = {
            macd: true,
            kd: true,
            rsi: true
        };

        // é è¨­é…ç½®æ¨¡æ¿ï¼ˆ4çµ„é…ç½®ï¼‰
        const defaultPresets = {
            1: { macd: -185, kd: 20, rsi: 20, klineUseKd: true, klineUseMacd: true, klineUseRsi: true },
            2: { macd: -250, kd: 25, rsi: 25, klineUseKd: true, klineUseMacd: true, klineUseRsi: false },
            3: { macd: -150, kd: 15, rsi: 15, klineUseKd: true, klineUseMacd: false, klineUseRsi: true },
            4: { macd: -300, kd: 30, rsi: 30, klineUseKd: false, klineUseMacd: true, klineUseRsi: true }
        };

        // æ¯å€‹é€±æœŸçš„é…ç½®å„²å­˜ï¼ˆ5å€‹é€±æœŸ x 4çµ„é…ç½®ï¼‰
        let periodPresets = {
            'daily': JSON.parse(JSON.stringify(defaultPresets)),
            'weekly': JSON.parse(JSON.stringify(defaultPresets)),
            'bi-weekly': JSON.parse(JSON.stringify(defaultPresets)),
            'tri-weekly': JSON.parse(JSON.stringify(defaultPresets)),
            'monthly': JSON.parse(JSON.stringify(defaultPresets))
        };

        let currentPreset = 1; // ç•¶å‰é¸ä¸­çš„é…ç½®ç·¨è™Ÿ

        // æ¨™è¨˜é–¾å€¼é…ç½®
        let thresholdConfig = {
            macd: -185,
            kd: 20,
            rsi: 20,
            masterEnabled: true,
            klineUseKd: true,
            klineUseMacd: true,
            klineUseRsi: true
        };

        // æ§åˆ¶é¢æ¿é‚è¼¯
        const controlPanel = document.getElementById('controlPanel');
        const openPanelBtn = document.getElementById('openPanelBtn');
        const closePanelBtn = document.getElementById('closePanelBtn');
        const masterSwitch = document.getElementById('masterSwitch');
        const kdThresholdInput = document.getElementById('kdThreshold');
        const rsiThresholdInput = document.getElementById('rsiThreshold');
        const macdThresholdInput = document.getElementById('macdThreshold');
        const kdValueDisplay = document.getElementById('kdValue');
        const rsiValueDisplay = document.getElementById('rsiValue');
        const macdValueDisplay = document.getElementById('macdValue');
        const useKdForKline = document.getElementById('useKdForKline');
        const useMacdForKline = document.getElementById('useMacdForKline');
        const useRsiForKline = document.getElementById('useRsiForKline');
        const presetButtons = document.querySelectorAll('.preset-btn');

        openPanelBtn.addEventListener('click', () => {
            controlPanel.classList.add('show');
        });

        closePanelBtn.addEventListener('click', () => {
            controlPanel.classList.remove('show');
        });

        // é»æ“Šè¦–çª—å¤–è‡ªå‹•æ”¶åˆ
        document.addEventListener('click', (e) => {
            if (controlPanel.classList.contains('show')) {
                if (!controlPanel.contains(e.target) && !openPanelBtn.contains(e.target)) {
                    controlPanel.classList.remove('show');
                }
            }
        });

        // è¼‰å…¥æŒ‡å®šé…ç½®
        function loadPreset(presetNumber) {
            const preset = periodPresets[currentPeriod][presetNumber];

            thresholdConfig.macd = preset.macd;
            thresholdConfig.kd = preset.kd;
            thresholdConfig.rsi = preset.rsi;
            thresholdConfig.klineUseKd = preset.klineUseKd;
            thresholdConfig.klineUseMacd = preset.klineUseMacd;
            thresholdConfig.klineUseRsi = preset.klineUseRsi;

            // æ›´æ–°UI
            macdThresholdInput.value = preset.macd;
            kdThresholdInput.value = preset.kd;
            rsiThresholdInput.value = preset.rsi;
            useKdForKline.checked = preset.klineUseKd;
            useMacdForKline.checked = preset.klineUseMacd;
            useRsiForKline.checked = preset.klineUseRsi;

            macdValueDisplay.textContent = preset.macd;
            kdValueDisplay.textContent = preset.kd;
            rsiValueDisplay.textContent = preset.rsi;

            currentPreset = presetNumber;

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            presetButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset == presetNumber);
            });

            updateChartMarkAreas();
        }

        // å„²å­˜ç•¶å‰é…ç½®åˆ°æŒ‡å®šé è¨­
        function saveCurrentPreset() {
            periodPresets[currentPeriod][currentPreset] = {
                macd: thresholdConfig.macd,
                kd: thresholdConfig.kd,
                rsi: thresholdConfig.rsi,
                klineUseKd: thresholdConfig.klineUseKd,
                klineUseMacd: thresholdConfig.klineUseMacd,
                klineUseRsi: thresholdConfig.klineUseRsi
            };
        }

        // é è¨­é…ç½®æŒ‰éˆ•äº‹ä»¶
        presetButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const presetNum = parseInt(btn.dataset.preset);
                loadPreset(presetNum);
            });
        });

        // ç›£è½é–¾å€¼è®ŠåŒ– - åªæ›´æ–°æ¨™è¨˜ï¼Œä¸é‡æ–°è¨ˆç®—æŠ€è¡“æŒ‡æ¨™
        function updateMarkAreas() {
            thresholdConfig.kd = parseFloat(kdThresholdInput.value);
            thresholdConfig.rsi = parseFloat(rsiThresholdInput.value);
            thresholdConfig.macd = parseFloat(macdThresholdInput.value);
            thresholdConfig.masterEnabled = masterSwitch.checked;
            thresholdConfig.klineUseKd = useKdForKline.checked;
            thresholdConfig.klineUseMacd = useMacdForKline.checked;
            thresholdConfig.klineUseRsi = useRsiForKline.checked;

            // æ›´æ–°é¡¯ç¤ºå€¼
            kdValueDisplay.textContent = thresholdConfig.kd;
            rsiValueDisplay.textContent = thresholdConfig.rsi;
            macdValueDisplay.textContent = thresholdConfig.macd;

            // å„²å­˜åˆ°ç•¶å‰é è¨­é…ç½®
            saveCurrentPreset();

            // åªæ›´æ–°åœ–è¡¨çš„ markAreaï¼Œä¸é‡æ–°æ¸²æŸ“æ•´å€‹åœ–è¡¨
            updateChartMarkAreas();
        }

        masterSwitch.addEventListener('change', updateMarkAreas);
        kdThresholdInput.addEventListener('input', updateMarkAreas);
        rsiThresholdInput.addEventListener('input', updateMarkAreas);
        macdThresholdInput.addEventListener('input', updateMarkAreas);
        useKdForKline.addEventListener('change', updateMarkAreas);
        useMacdForKline.addEventListener('change', updateMarkAreas);
        useRsiForKline.addEventListener('change', updateMarkAreas);

        // å­˜å„²ç•¶å‰åœ–è¡¨æ•¸æ“šï¼Œç”¨æ–¼å¿«é€Ÿæ›´æ–°æ¨™è¨˜å€åŸŸ
        let currentChartData = null;

        // ç”Ÿæˆæ¨™è¨˜å€åŸŸ
        function generateMarkAreas(data, threshold, color) {
            if (!thresholdConfig.masterEnabled) return [];

            const markAreaData = [];
            let inLowZone = false;
            let startIdx = null;

            for (let i = 0; i < data.length; i++) {
                if (data[i] !== null && data[i] < threshold) {
                    if (!inLowZone) {
                        startIdx = i;
                        inLowZone = true;
                    }
                } else {
                    if (inLowZone && startIdx !== null) {
                        markAreaData.push([
                            { xAxis: startIdx, itemStyle: { color: color, opacity: 0.3 } },
                            { xAxis: i - 1 }
                        ]);
                        inLowZone = false;
                        startIdx = null;
                    }
                }
            }

            // è™•ç†çµå°¾ä»åœ¨ä½æª”å€çš„æƒ…æ³
            if (inLowZone && startIdx !== null) {
                markAreaData.push([
                    { xAxis: startIdx, itemStyle: { color: color, opacity: 0.3 } },
                    { xAxis: data.length - 1 }
                ]);
            }

            return markAreaData;
        }

        // ç”ŸæˆKç·šå¤šæŒ‡æ¨™äº¤é›†æ¨™è¨˜
        function generateKlineMarkAreas(kdData, macdData, rsiData) {
            if (!thresholdConfig.masterEnabled) return [];

            const markAreaData = [];
            let inCombinedZone = false;
            let startIdx = null;

            for (let i = 0; i < kdData.length; i++) {
                let meetsCriteria = true;

                if (thresholdConfig.klineUseKd) {
                    if (kdData[i] === null || kdData[i] >= thresholdConfig.kd) meetsCriteria = false;
                }

                if (thresholdConfig.klineUseMacd) {
                    if (macdData[i] === null || macdData[i] >= thresholdConfig.macd) meetsCriteria = false;
                }

                if (thresholdConfig.klineUseRsi) {
                    if (rsiData[i] === null || rsiData[i] >= thresholdConfig.rsi) meetsCriteria = false;
                }

                if (meetsCriteria) {
                    if (!inCombinedZone) {
                        startIdx = i;
                        inCombinedZone = true;
                    }
                } else {
                    if (inCombinedZone && startIdx !== null) {
                        markAreaData.push([
                            { xAxis: startIdx, itemStyle: { color: '#FFD700', opacity: 0.25 } },
                            { xAxis: i - 1 }
                        ]);
                        inCombinedZone = false;
                        startIdx = null;
                    }
                }
            }

            if (inCombinedZone && startIdx !== null) {
                markAreaData.push([
                    { xAxis: startIdx, itemStyle: { color: '#FFD700', opacity: 0.25 } },
                    { xAxis: kdData.length - 1 }
                ]);
            }

            return markAreaData;
        }

        // å¿«é€Ÿæ›´æ–°æ¨™è¨˜å€åŸŸï¼ˆä¸é‡æ–°æ¸²æŸ“æŠ€è¡“ç·šåœ–ï¼‰
        function updateChartMarkAreas() {
            if (!currentChartData) return;

            const { kdResult, macdResult, rsi5, resampledData, visibleIndicators } = currentChartData;

            // æ›´æ–°æ¯å€‹æŒ‡æ¨™çš„æ¨™è¨˜å€åŸŸ
            const updatedSeries = myChart.getOption().series.map((s, idx) => {
                // Kç·šåœ–çš„æ¨™è¨˜ï¼ˆç³»åˆ—0ï¼‰
                if (s.type === 'candlestick') {
                    return {
                        ...s,
                        markArea: {
                            data: generateKlineMarkAreas(kdResult.k, macdResult.dm, rsi5)
                        }
                    };
                }

                // KD çš„ Kç·šæ¨™è¨˜
                if (s.name === 'K(9)') {
                    return {
                        ...s,
                        markArea: {
                            data: generateMarkAreas(kdResult.k, thresholdConfig.kd, '#FF6B6B')
                        }
                    };
                }

                // RSI(5T) çš„æ¨™è¨˜
                if (s.name === 'RSI(5T)') {
                    return {
                        ...s,
                        markArea: {
                            data: generateMarkAreas(rsi5, thresholdConfig.rsi, '#FF8C00')
                        }
                    };
                }

                // MACD D-M çš„æ¨™è¨˜
                if (s.name === 'D-M') {
                    return {
                        ...s,
                        markArea: {
                            data: generateMarkAreas(macdResult.dm, thresholdConfig.macd, '#DA6EE8')
                        }
                    };
                }

                return s;
            });

            myChart.setOption({
                series: updatedSeries
            });
        }

        function updateChart(periodType) {
            console.time(`UpdateChart-${periodType}`);
            currentPeriod = periodType;

            controlButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.period === periodType);
            });

            statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šæ­£åœ¨å°‡ ${dailyData.length.toLocaleString()} ç­†æ—¥Kè½‰æ›ç‚º ${periodType} è³‡æ–™...`;
            console.time(`Resample-${periodType}`);
            const resampledData = DataService.resampleToPeriod(dailyData, periodType);
            console.timeEnd(`Resample-${periodType}`);

            const closePrices = resampledData.map(item => item.close);
            const macdResult = TechUtils.calculateMACD(closePrices);
            const kdResult = TechUtils.calculateKD(resampledData);
            const rsi5 = TechUtils.calculateRSI(closePrices, 5);  // å¿«ç·š (ä¸€é€±)
            const rsi10 = TechUtils.calculateRSI(closePrices, 10); // æ…¢ç·š (å…©é€±)
            const ma5 = TechUtils.calculateSMA(closePrices, 5);
            const ma10 = TechUtils.calculateSMA(closePrices, 10);
            const ma20 = TechUtils.calculateSMA(closePrices, 20);
            const ma60 = TechUtils.calculateSMA(closePrices, 60);

            const periodMap = { 'daily': 'æ—¥ç·š', 'weekly': 'å‘¨ç·š', 'bi-weekly': 'é›™å‘¨ç·š', 'tri-weekly': 'ä¸‰å‘¨ç·š', 'monthly': 'æœˆç·š' };
            const periodName = periodMap[periodType];
            chartTitleEl.innerHTML = `ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸ ${periodName} <span class="badge">Real Data</span>`;

            statusEl.innerHTML = `
                çµ±è¨ˆç¯„åœï¼š<b>${dailyData[0].date}</b> è‡³ <b>${dailyData[dailyData.length-1].date}</b><br>
                åŸå§‹æ—¥Kï¼š${dailyData.length.toLocaleString()} ç­† |
                èšåˆ${periodName}ï¼š${resampledData.length.toLocaleString()} ç­†
            `;

            // å‹•æ…‹è¨ˆç®—ç¶²æ ¼å¸ƒå±€
            const visibleIndicators = [];
            if (indicatorVisible.macd) visibleIndicators.push('macd');
            if (indicatorVisible.kd) visibleIndicators.push('kd');
            if (indicatorVisible.rsi) visibleIndicators.push('rsi');

            const indicatorCount = visibleIndicators.length;
            const indicatorHeight = 11.5; // æ¯å€‹æŒ‡æ¨™é«˜åº¦ç™¾åˆ†æ¯”
            const spacingBetweenCharts = 2.5; // åœ–è¡¨ä¹‹é–“çš„é–“è·ç™¾åˆ†æ¯”
            const totalSpacing = indicatorCount > 0 ? indicatorCount * spacingBetweenCharts : 0;
            const kLineHeight = 86 - (indicatorCount * indicatorHeight) - totalSpacing - 3; // Kç·šåœ–é«˜åº¦(ç•™3%çµ¦dataZoom)

            // å»ºç«‹ç¶²æ ¼é…ç½®
            const grids = [{ left: '50px', right: '5%', top: '12%', height: `${kLineHeight}%` }];
            const titles = [
                { text: `å°ç£åŠ æ¬ŠæŒ‡æ•¸ (${periodName})`, left: 'center', top: 0 },
                { text: 'Kç·š', left: '70px', top: '12%', textStyle: { fontSize: 14, fontWeight: 'bold', color: '#333' } }
            ];

            let currentTop = 12 + kLineHeight + spacingBetweenCharts; // ç•¶å‰ä½ç½®
            let gridIndex = 1;
            const xAxisConfigs = [{ type: 'category', data: resampledData.map(d => d.date), axisLabel: { show: false } }];
            const yAxisConfigs = [{
                scale: true,
                splitLine: { show: true, lineStyle: { color: '#eee' } },
                axisLabel: {
                    formatter: function(value) {
                        return value.toLocaleString();
                    }
                }
            }];
            const xAxisIndices = [0];

            visibleIndicators.forEach((indicator, idx) => {
                grids.push({ left: '50px', right: '5%', top: `${currentTop}%`, height: `${indicatorHeight}%` });
                titles.push({ text: indicator.toUpperCase(), left: '70px', top: `${currentTop}%`, textStyle: { fontSize: 14, fontWeight: 'bold', color: '#333' } });
                xAxisConfigs.push({ type: 'category', gridIndex: gridIndex, data: resampledData.map(d => d.date), axisLabel: { show: false } });
                xAxisIndices.push(gridIndex);

                if (indicator === 'macd') {
                    yAxisConfigs.push({ scale: true, gridIndex: gridIndex, splitLine: { show: false } });
                } else {
                    yAxisConfigs.push({ scale: true, gridIndex: gridIndex, min: 0, max: 100, splitLine: { show: true, lineStyle: { color: '#eee' } } });
                }

                currentTop += indicatorHeight + spacingBetweenCharts;
                gridIndex++;
            });

            // å­˜å„²ç•¶å‰åœ–è¡¨æ•¸æ“š
            currentChartData = {
                kdResult,
                macdResult,
                rsi5,
                resampledData,
                visibleIndicators
            };

            // å»ºç«‹ç³»åˆ—æ•¸æ“š
            const series = [
                {
                    name: periodName,
                    type: 'candlestick',
                    data: resampledData.map(d => d.values),
                    itemStyle: { color: '#eb5454', color0: '#47b262', borderColor: '#eb5454', borderColor0: '#47b262' },
                    large: true,
                    markArea: {
                        data: generateKlineMarkAreas(kdResult.k, macdResult.dm, rsi5)
                    }
                },
                { name: 'MA5', type: 'line', data: ma5, smooth: true, lineStyle: { width: 1.5, color: '#FFBF00' }, symbol: 'none' },
                { name: 'MA10', type: 'line', data: ma10, smooth: true, lineStyle: { width: 1.5, color: '#8A2BE2' }, symbol: 'none' },
                { name: 'MA20', type: 'line', data: ma20, smooth: true, lineStyle: { width: 1.5, color: '#32CD32' }, symbol: 'none' },
                { name: 'MA60', type: 'line', data: ma60, smooth: true, lineStyle: { width: 1.5, color: '#FF1493' }, symbol: 'none' }
            ];

            const legendData = [
                { name: 'MA5', itemStyle: { color: '#FFBF00' } },
                { name: 'MA10', itemStyle: { color: '#8A2BE2' } },
                { name: 'MA20', itemStyle: { color: '#32CD32' } },
                { name: 'MA60', itemStyle: { color: '#FF1493' } }
            ];

            // æ ¹æ“šå¯è¦‹æ€§æ·»åŠ æŒ‡æ¨™ç³»åˆ—
            visibleIndicators.forEach((indicator, idx) => {
                const axisIndex = idx + 1;

                if (indicator === 'macd') {
                    legendData.push(
                        { name: 'DIF', itemStyle: { color: '#DA6EE8' } },
                        { name: 'MACD', itemStyle: { color: '#00D5FA' } }
                    );
                    series.push(
                        { name: 'DIF', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.dif, lineStyle: { color: '#DA6EE8', width: 1.5 }, symbol: 'none' },
                        { name: 'MACD', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.macd, lineStyle: { color: '#00D5FA', width: 1.5 }, symbol: 'none' },
                        {
                            name: 'D-M',
                            type: 'bar',
                            xAxisIndex: axisIndex,
                            yAxisIndex: axisIndex,
                            data: macdResult.dm,
                            itemStyle: { color: (p) => p.value > 0 ? '#eb5454' : '#47b262' },
                            markArea: {
                                data: generateMarkAreas(macdResult.dm, thresholdConfig.macd, '#DA6EE8')
                            }
                        }
                    );
                } else if (indicator === 'kd') {
                    legendData.push(
                        { name: 'K(9)', itemStyle: { color: '#FF6B6B' } },
                        { name: 'D(9)', itemStyle: { color: '#4ECDC4' } }
                    );
                    series.push(
                        {
                            name: 'K(9)',
                            type: 'line',
                            xAxisIndex: axisIndex,
                            yAxisIndex: axisIndex,
                            data: kdResult.k,
                            lineStyle: { color: '#FF6B6B', width: 1.5 },
                            symbol: 'none',
                            markArea: {
                                data: generateMarkAreas(kdResult.k, thresholdConfig.kd, '#FF6B6B')
                            }
                        },
                        { name: 'D(9)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: kdResult.d, lineStyle: { color: '#4ECDC4', width: 1.5 }, symbol: 'none' },
                        {
                            name: 'KDè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(80),
                            lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'KDè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(20),
                            lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        }
                    );
                } else if (indicator === 'rsi') {
                    legendData.push(
                        { name: 'RSI(5T)', itemStyle: { color: '#FF8C00' } },
                        { name: 'RSI(10T)', itemStyle: { color: '#9370DB' } }
                    );
                    series.push(
                        {
                            name: 'RSI(5T)',
                            type: 'line',
                            xAxisIndex: axisIndex,
                            yAxisIndex: axisIndex,
                            data: rsi5,
                            lineStyle: { color: '#FF8C00', width: 2 },
                            symbol: 'none',
                            markArea: {
                                data: generateMarkAreas(rsi5, thresholdConfig.rsi, '#FF8C00')
                            }
                        },
                        { name: 'RSI(10T)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: rsi10, lineStyle: { color: '#9370DB', width: 2 }, symbol: 'none' },
                        {
                            name: 'RSIè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(80),
                            lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'RSIè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(20),
                            lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                            symbol: 'none', silent: true, animation: false
                        },
                        {
                            name: 'RSIä¸­ç·š', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                            data: new Array(resampledData.length).fill(50),
                            lineStyle: { color: '#999', width: 1, type: 'dotted' },
                            symbol: 'none', silent: true, animation: false
                        }
                    );
                }
            });

            const option = {
                title: titles,
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
                axisPointer: { link: { xAxisIndex: 'all' } },
                legend: {
                    top: 30,
                    data: legendData
                },
                grid: grids,
                xAxis: xAxisConfigs,
                yAxis: yAxisConfigs,
                dataZoom: [
                    { type: 'inside', xAxisIndex: xAxisIndices, start: 95, end: 100 },
                    { type: 'slider', xAxisIndex: xAxisIndices, top: '97%', start: 95, end: 100 }
                ],
                series: series
            };

            myChart.setOption(option, true);
            console.timeEnd(`UpdateChart-${periodType}`);
        }

        controlButtons.forEach(button => {
            button.addEventListener('click', () => {
                const period = button.dataset.period;
                if (period !== currentPeriod) {
                    currentPeriod = period;
                    updateChart(period);
                    // åˆ‡æ›é€±æœŸæ™‚è¼‰å…¥è©²é€±æœŸçš„ç•¶å‰é…ç½®
                    loadPreset(currentPreset);
                }
            });
        });

        // æŒ‡æ¨™é–‹é—œæŒ‰éˆ•
        const indicatorCheckboxes = document.querySelectorAll('.indicator-checkbox input[type="checkbox"]');
        indicatorCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const indicator = checkbox.dataset.indicator;
                indicatorVisible[indicator] = checkbox.checked;
                updateChart(currentPeriod);
            });
        });

        updateChart(currentPeriod);
        window.addEventListener('resize', myChart.resize);
    }

    initApp();
</script>

</body>
</html>