<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/weekOfYear.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;600;700&display=swap"
        rel="stylesheet">

    <style>
        /* ===== CSS è®Šæ•¸å®šç¾© ===== */
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-card: rgba(17, 24, 39, 0.85);
            --bg-glass: rgba(30, 41, 59, 0.6);
            --bg-hover: rgba(59, 130, 246, 0.1);

            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;

            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;

            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-danger: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);

            --border-color: rgba(148, 163, 184, 0.1);
            --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 30px rgba(59, 130, 246, 0.2);

            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;

            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
        }

        /* ===== æ·ºè‰²ä¸»é¡Œ ===== */
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #ffffff;
            --bg-card: rgba(255, 255, 255, 1);
            --bg-glass: rgba(255, 255, 255, 1);
            --bg-hover: rgba(59, 130, 246, 0.08);

            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #94a3b8;

            --border-color: rgba(51, 65, 85, 0.15);
            --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.08);
            --shadow-glow: 0 0 30px rgba(59, 130, 246, 0.05);
        }

        [data-theme="light"] .status {
            background: rgba(59, 130, 246, 0.08);
        }

        [data-theme="light"] #chart {
            background: rgba(255, 255, 255, 1);
        }

        [data-theme="light"] .card::before {
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.05), transparent);
        }

        /* ===== æ·±è‰²æ¨¡å¼å´é‚Šé¢æ¿åº•è‰²èª¿äº® ===== */
        :root .floating-panel,
        :root .sidebar {
            background: rgba(50, 60, 80, 0.95);
        }

        [data-theme="light"] .floating-panel,
        [data-theme="light"] .sidebar {
            background: var(--bg-card);
        }

        /* ===== ä¸»é¡Œåˆ‡æ›é–‹é—œæ¨£å¼ ===== */
        .theme-toggle-label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all var(--transition-normal);
        }

        .theme-toggle-label:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        .theme-icon {
            font-size: 1.2em;
            transition: transform var(--transition-normal);
        }

        .theme-text {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-secondary);
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', 'Noto Sans TC', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            background-image:
                radial-gradient(ellipse at 20% 20%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(139, 92, 246, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(16, 185, 129, 0.05) 0%, transparent 70%);
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--text-primary);
            padding: 24px;
            line-height: 1.6;
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            padding: 32px;
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            position: relative;
            overflow: hidden;
            animation: fadeIn 0.6s ease-out;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }

        h2 {
            margin-top: 0;
            margin-bottom: 24px;
            color: var(--text-primary);
            font-size: 1.75rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            padding-left: 16px;
        }

        h2::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 70%;
            background: var(--gradient-primary);
            border-radius: 2px;
        }

        #chart {
            width: 100%;
            height: 900px;
            border-radius: var(--radius-lg);
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
        }

        .status {
            margin-bottom: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--accent-primary);
            line-height: 1.8;
        }

        .status::before {
            content: 'â— ';
            color: var(--accent-success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .badge {
            background: var(--gradient-success);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .controls {
            margin-bottom: 24px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 20px;
            background: var(--bg-glass);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
        }

        .controls>* {
            flex-shrink: 0;
        }

        .btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: var(--gradient-primary);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
        }

        .indicator-checkbox {
            display: inline-flex;
            align-items: center;
            margin: 0 8px;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            user-select: none;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-sm);
            border: 1px solid transparent;
            transition: all var(--transition-normal);
        }

        .indicator-checkbox:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .indicator-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        .config-dropdown-label {
            display: inline-flex;
            align-items: center;
            margin-left: 16px;
            font-size: 0.9em;
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .config-dropdown {
            margin-left: 10px;
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9em;
            cursor: pointer;
            transition: all var(--transition-normal);
            outline: none;
        }

        .config-dropdown:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        .config-dropdown:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .config-dropdown option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .config-notes {
            display: inline-block;
            margin-left: 16px;
            padding: 16px 20px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: var(--radius-md);
            font-size: 0.85em;
            color: #fbbf24;
            min-width: 400px;
            max-width: 700px;
            max-height: 200px;
            line-height: 1.7;
            vertical-align: top;
            overflow-y: auto;
            overflow-x: hidden;
            word-wrap: break-word;
            white-space: normal;
            backdrop-filter: blur(10px);
        }

        .config-notes h4 {
            margin: 0 0 12px 0;
            font-size: 1em;
            color: #fbbf24;
            font-weight: 600;
        }

        .config-notes ol {
            margin: 0;
            padding-left: 20px;
        }

        .config-notes li {
            margin: 8px 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .config-notes.hidden {
            display: none;
        }

        .config-notes::-webkit-scrollbar {
            width: 6px;
        }

        .config-notes::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .config-notes::-webkit-scrollbar-thumb {
            background: rgba(245, 158, 11, 0.5);
            border-radius: 3px;
        }

        .floating-panel {
            position: fixed;
            top: 50%;
            right: -360px;
            transform: translateY(-50%);
            width: 360px;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius-xl) 0 0 var(--radius-xl);
            border: 1px solid var(--border-color);
            border-right: none;
            box-shadow: var(--shadow-lg);
            transition: right var(--transition-normal);
            z-index: 1000;
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
        }

        .floating-panel.open {
            right: 0;
            display: block;
        }

        .panel-toggle {
            position: absolute;
            left: -48px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--gradient-primary);
            color: white;
            border: none;
            width: 48px;
            height: 64px;
            border-radius: var(--radius-md) 0 0 var(--radius-md);
            cursor: pointer;
            font-size: 22px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-toggle:hover {
            width: 54px;
            left: -54px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.5), 0 0 20px rgba(102, 126, 234, 0.4);
        }

        .panel-content {
            padding: 24px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .panel-section {
            margin-bottom: 8px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            transition: all var(--transition-normal);
        }

        .panel-section:hover {
            border-color: rgba(59, 130, 246, 0.3);
        }

        .panel-section:last-child {
            margin-bottom: 0;
        }

        .panel-section.hidden {
            display: none;
        }

        .panel-section h3 {
            margin: 0 0 16px 0;
            font-size: 1em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .range-input {
            margin-bottom: 8px;
        }

        .range-input label {
            display: block;
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .range-control {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .range-slider-container {
            flex: 1;
            min-width: 0;
        }

        .range-slider-wrapper {
            position: relative;
            padding: 0 6px;
        }

        .range-slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        .range-slider-container input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            border-radius: 10px;
            background: linear-gradient(90deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            opacity: 0.3;
        }

        .range-slider-container input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            border-radius: 10px;
            background: linear-gradient(90deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            opacity: 0.3;
        }

        .range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--gradient-primary);
            border: 3px solid var(--bg-secondary);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
            transition: all var(--transition-fast);
            margin-top: -8px;
        }

        .range-slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.6);
        }

        .range-slider-container input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--gradient-primary);
            border: 3px solid var(--bg-secondary);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
        }

        .range-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 0 6px;
        }

        .range-labels span {
            font-size: 0.8em;
            color: var(--text-muted);
            font-weight: 500;
        }

        .range-control input[type="number"] {
            width: 75px;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-secondary);
            font-size: 0.9em;
            text-align: center;
            font-weight: 600;
            color: var(--text-primary);
            transition: all var(--transition-normal);
        }

        .range-control input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .range-value-display {
            min-width: 50px;
            text-align: center;
            font-weight: 700;
            color: var(--accent-primary);
            font-size: 1em;
        }

        .zone-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 14px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .zone-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        .zone-checkbox label:not(.toggle-switch) {
            cursor: pointer;
            user-select: none;
            transition: color var(--transition-fast);
        }

        .zone-checkbox:hover label:not(.toggle-switch) {
            color: var(--text-primary);
        }

        .zone-checkbox input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.4;
        }

        .zone-checkbox:has(input:disabled) {
            opacity: 0.5;
            color: var(--text-muted);
        }

        /* å‡ç·šè¨­å®šé¢æ¿æ¨£å¼ */
        .ma-setting-item {
            padding: 12px !important;
        }

        .ma-setting-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .ma-label {
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .ma-period-input {
            width: 60px;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9em;
            font-weight: 600;
            text-align: center;
        }

        .ma-period-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .ma-color-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 64px;
        }

        .ma-color-row label {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .ma-color-input {
            width: 40px;
            height: 30px;
            padding: 0;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-sm);
            cursor: pointer;
            background: transparent;
        }

        .ma-color-input::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        .ma-color-input::-webkit-color-swatch {
            border-radius: 4px;
            border: none;
        }

        .ma-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--bg-secondary);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .master-toggle {
            background: var(--gradient-danger);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--radius-md);
            cursor: pointer;
            width: 100%;
            font-size: 0.95em;
            font-weight: 600;
            transition: all var(--transition-normal);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .master-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }

        .master-toggle.active {
            background: var(--gradient-success);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .master-toggle.active:hover {
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
            margin-right: 12px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(100, 116, 139, 0.5);
            transition: all var(--transition-normal);
            border-radius: 28px;
            border: 1px solid var(--border-color);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 2px;
            bottom: 2px;
            background: white;
            transition: all var(--transition-normal);
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch input:checked+.toggle-slider {
            background: var(--gradient-success);
            border-color: transparent;
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-switch:hover .toggle-slider {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .toggle-switch input:disabled+.toggle-slider {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toggle-switch input:disabled+.toggle-slider:before {
            background: #94a3b8;
        }

        .panel-control-btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            margin-left: 16px;
            transition: all var(--transition-normal);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .panel-control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .panel-control-btn:active {
            transform: translateY(-1px);
        }

        .panel-control-btn.panel-open {
            background: linear-gradient(135deg, #ec4899 0%, #f43f5e 100%);
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.3);
        }

        .sidebar {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 56px;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--radius-lg) 0 0 var(--radius-lg);
            border: 1px solid var(--border-color);
            border-right: none;
            box-shadow: var(--shadow-lg);
            z-index: 1001;
            transition: all var(--transition-normal);
            overflow: hidden;
        }

        .sidebar.panel-open {
            right: 360px;
        }

        .sidebar:hover {
            width: 160px;
        }

        .sidebar-bookmark {
            position: relative;
            padding: 16px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all var(--transition-normal);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
        }

        .sidebar-bookmark:last-child {
            border-bottom: none;
        }

        .sidebar-bookmark:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .sidebar-bookmark.active {
            background: var(--gradient-primary);
            color: white;
        }

        .sidebar-bookmark-icon {
            min-width: 24px;
            font-size: 20px;
            margin-right: 12px;
        }

        .sidebar-bookmark-text {
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .sidebar:hover .sidebar-bookmark-text {
            opacity: 1;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
            opacity: 0.5;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }

        @media (max-width: 768px) {
            body {
                padding: 12px;
            }

            .card {
                padding: 20px;
                border-radius: var(--radius-lg);
            }

            h2 {
                font-size: 1.4rem;
            }

            .controls {
                padding: 16px;
                gap: 10px;
            }

            .config-notes {
                min-width: 0;
                width: 100%;
                margin-left: 0;
                margin-top: 12px;
            }

            .floating-panel {
                width: 300px;
                right: -300px;
            }

            .floating-panel.open {
                right: 0;
            }

            .sidebar {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                transform: none;
                width: 100%;
                height: 56px;
                flex-direction: row;
                display: flex;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                border: 1px solid var(--border-color);
                border-bottom: none;
                justify-content: space-around;
                z-index: 1001;
            }

            .sidebar:hover {
                width: 100%;
            }

            .sidebar-bookmark {
                flex: 1;
                flex-direction: column;
                justify-content: center;
                padding: 8px 4px;
                border-bottom: none;
                border-right: 1px solid var(--border-color);
                text-align: center;
            }

            .sidebar-bookmark:last-child {
                border-right: none;
            }

            .sidebar-bookmark-icon {
                min-width: auto;
                font-size: 18px;
                margin-right: 0;
                margin-bottom: 2px;
            }

            .sidebar-bookmark-text {
                font-size: 10px;
                opacity: 1;
                display: block;
            }

            .sidebar:hover .sidebar-bookmark-text {
                opacity: 1;
            }

            .sidebar.panel-open {
                right: 0;
            }

            .floating-panel.open {
                width: 100%;
                max-width: 100%;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                bottom: 56px;
                top: auto;
                transform: none;
                max-height: 60vh;
            }

            #chart {
                height: 600px;
                margin-bottom: 60px;
            }

            .card {
                margin-bottom: 70px;
            }
        }
    </style>
</head>

<body>

    <!-- å³å´æ›¸ç±¤å´é‚Šæ¬„ -->
    <div class="sidebar">
        <div class="sidebar-bookmark" id="macdReversalBookmark">
            <span class="sidebar-bookmark-icon">ğŸ”„</span>
            <span class="sidebar-bookmark-text">MACDåè½‰</span>
        </div>
        <div class="sidebar-bookmark" id="highPriceAreaBookmark">
            <span class="sidebar-bookmark-icon">ğŸ”´</span>
            <span class="sidebar-bookmark-text">é«˜æª”æ¨™è¨˜</span>
        </div>
        <div class="sidebar-bookmark" id="lowPriceAreaBookmark">
            <span class="sidebar-bookmark-icon">ğŸŸ¢</span>
            <span class="sidebar-bookmark-text">ä½æª”æ¨™è¨˜</span>
        </div>
        <div class="sidebar-bookmark" id="maSettingsBookmark">
            <span class="sidebar-bookmark-icon">ğŸ“ˆ</span>
            <span class="sidebar-bookmark-text">å‡ç·šè¨­å®š</span>
        </div>
    </div>

    <div class="card">
        <h2 id="chart-title">ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬(Beta ç‰ˆ) <span class="badge">Real Data</span></h2>
        <div class="controls">
            <button class="btn active" data-period="daily">æ—¥ç·š</button>
            <button class="btn" data-period="weekly">å‘¨ç·š</button>
            <button class="btn" data-period="bi-weekly">é›™å‘¨ç·š</button>
            <button class="btn" data-period="tri-weekly">ä¸‰å‘¨ç·š</button>
            <button class="btn" data-period="monthly">æœˆç·š</button>
            <label class="indicator-checkbox">
                <input type="checkbox" data-indicator="macd" checked> MACD
            </label>
            <label class="indicator-checkbox">
                <input type="checkbox" data-indicator="kd" checked> KD
            </label>
            <label class="indicator-checkbox">
                <input type="checkbox" data-indicator="rsi" checked> RSI
            </label>
            <label class="indicator-checkbox">
                <input type="checkbox" id="multiCrosshairToggle"> å¤šé»åå­—ç·š
            </label>
            <button id="clearCrosshairBtn" class="btn">æ¸…ç©ºåå­—ç·š</button>
            <label class="theme-toggle-label">
                <span class="theme-icon">ğŸŒ™</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="themeToggle">
                    <span class="toggle-slider"></span>
                </label>
                <span class="theme-text">æ·±è‰²</span>
            </label>
            <label class="config-dropdown-label">
                æ¨è–¦é…ç½®ï¼š
                <select id="configDropdown" class="config-dropdown">
                    <option value="">-- è«‹é¸æ“‡é…ç½® --</option>
                    <option value="easyMonthly">è¼•é¬†æœˆæ”¾</option>
                </select>
            </label>
            <div id="configNotes" class="config-notes hidden">
                <h4>ğŸ“‹ ä½¿ç”¨æ³¨æ„äº‹é …</h4>
                <ol id="configNotesList"></ol>
            </div>
        </div>
        <div class="status" id="status">ç³»çµ±ç‹€æ…‹ï¼šåˆå§‹åŒ–...</div>
        <div id="chart"></div>
    </div>

    <!-- MACDåè½‰æµ®å‹•æ§åˆ¶é¢æ¿ -->
    <div class="floating-panel" id="macdReversalPanel">
        <button class="panel-toggle" id="macdReversalPanelToggle">âš™ï¸</button>
        <div class="panel-content">

            <div class="panel-section">
                <h3>ğŸ”„ MACDåè½‰æ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="macdBuySellMasterToggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="macdBuySellMasterToggle" style="font-size: 1em; font-weight: 500;">é¡¯ç¤ºæ‰€æœ‰åè½‰æ¨™è¨˜</label>
                </div>
            </div>

            <div class="panel-section">
                <h3>ğŸ”´ MACDé«˜é»é–¥å€¼æ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="macdSellToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="macdSellToggle">é¡¯ç¤ºé«˜é»æ¨™è¨˜ï¼ˆæ·±ç´…è‰²ï¼‰</label>
                </div>
                <div class="range-input">
                    <label>é«˜é»é–¾å€¼ï¼ˆD-Mæ­£å€¼åè½‰å¾Œé«˜æ–¼æ­¤å€¼ï¼‰:</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="macdSellThresholdRange" min="-1500" max="1500" step="5"
                                    value="0">
                            </div>
                            <div class="range-labels">
                                <span>-1500</span>
                                <span>1500</span>
                            </div>
                        </div>
                        <input type="number" id="macdSellThreshold" min="-1500" max="1500" step="5" value="0">
                    </div>
                </div>
                <p style="font-size: 0.85em; color: #666; margin: 8px 0 0 0; line-height: 1.4;">
                    ç•¶ MACD D-M å¾æ­£å€¼å€å‘ä¸‹åè½‰ï¼Œä¸”åè½‰å¾Œçš„å€¼é«˜æ–¼é–¾å€¼æ™‚æ¨™è¨˜
                </p>
            </div>

            <div class="panel-section">
                <h3>ğŸŸ¢ MACDä½é»é–¥å€¼æ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="macdBuyToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="macdBuyToggle">é¡¯ç¤ºä½é»æ¨™è¨˜ï¼ˆå¢¨ç¶ è‰²ï¼‰</label>
                </div>
                <div class="range-input">
                    <label>ä½é»é–¾å€¼ï¼ˆD-Mè² å€¼åè½‰å¾Œä½æ–¼æ­¤å€¼ï¼‰:</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="macdBuyThresholdRange" min="-1500" max="1500" step="5"
                                    value="0">
                            </div>
                            <div class="range-labels">
                                <span>-1500</span>
                                <span>1500</span>
                            </div>
                        </div>
                        <input type="number" id="macdBuyThreshold" min="-1500" max="1500" step="5" value="0">
                    </div>
                </div>
                <p style="font-size: 0.85em; color: #666; margin: 8px 0 0 0; line-height: 1.4;">
                    ç•¶ MACD D-M å¾è² å€¼å€å‘ä¸Šåè½‰ï¼Œä¸”åè½‰å¾Œçš„å€¼ä½æ–¼é–¾å€¼æ™‚æ¨™è¨˜
                </p>
            </div>
        </div>
    </div>

    <!-- é«˜æª”å€åŸŸæµ®å‹•æ§åˆ¶é¢æ¿ -->
    <div class="floating-panel" id="highPricePanel">
        <button class="panel-toggle" id="highPanelToggle">âš™ï¸</button>
        <div class="panel-content">
            <div class="panel-section">
                <h3>é«˜æª”å€åŸŸæ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="highMasterToggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="highMasterToggle" style="font-size: 1em; font-weight: 500;">é–‹å•Ÿæ‰€æœ‰é«˜æª”æ¨™è¨˜</label>
                </div>
            </div>

            <div class="panel-section" data-indicator="macd" id="highMacdSection">
                <h3>ğŸ“ˆ MACD æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>é«˜æª”å€åŸŸ (é«˜æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="highMacdThresholdRange" class="macd-range" min="-500" max="1000"
                                    step="5" value="0">
                            </div>
                            <div class="range-labels macd-labels">
                                <span>-500</span>
                                <span>1000</span>
                            </div>
                        </div>
                        <input type="number" id="highMacdThreshold" min="-500" max="1000" step="5" value="0">
                    </div>
                </div>
            </div>

            <div class="panel-section" data-indicator="kd" id="highKdSection">
                <h3>ğŸ“Š KD æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>è¶…è²·å€åŸŸ (Kå€¼é«˜æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="highKdThresholdRange" class="kd-range" min="20" max="100"
                                    step="1" value="70">
                            </div>
                            <div class="range-labels">
                                <span>20</span>
                                <span>100</span>
                            </div>
                        </div>
                        <input type="number" id="highKdThreshold" min="20" max="100" step="1" value="70">
                    </div>
                </div>
            </div>

            <div class="panel-section" data-indicator="rsi" id="highRsiSection">
                <h3>ğŸ“ˆ RSI æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>è¶…è²·å€åŸŸ (é«˜æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="highRsiThresholdRange" class="rsi-range" min="20" max="100"
                                    step="1" value="70">
                            </div>
                            <div class="range-labels rsi-labels">
                                <span>20</span>
                                <span>100</span>
                            </div>
                        </div>
                        <input type="number" id="highRsiThreshold" min="20" max="100" step="1" value="70">
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>ğŸ¯ Kç·šå€è¤‡åˆæ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="highCompositeMACD" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="highCompositeMACD">æ¡ç”¨ MACD æ¢ä»¶</label>
                </div>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="highCompositeKD" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="highCompositeKD">æ¡ç”¨ KD æ¢ä»¶</label>
                </div>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="highCompositeRSI" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="highCompositeRSI">æ¡ç”¨ RSI æ¢ä»¶</label>
                </div>
            </div>
        </div>
    </div>

    <!-- ä½æª”å€åŸŸæµ®å‹•æ§åˆ¶é¢æ¿ -->
    <div class="floating-panel" id="lowPricePanel">
        <button class="panel-toggle" id="lowPanelToggle">âš™ï¸</button>
        <div class="panel-content">
            <div class="panel-section">
                <h3>ä½æª”å€åŸŸæ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="masterToggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="masterToggle" style="font-size: 1em; font-weight: 500;">é–‹å•Ÿæ‰€æœ‰ä½æª”æ¨™è¨˜</label>
                </div>
            </div>

            <div class="panel-section" data-indicator="macd">
                <h3>ğŸ“‰ MACD æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>ä½æª”å€åŸŸ (ä½æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="macdThresholdRange" class="macd-range" min="-1000" max="500"
                                    step="5" value="0">
                            </div>
                            <div class="range-labels macd-labels">
                                <span>-1000</span>
                                <span>500</span>
                            </div>
                        </div>
                        <input type="number" id="macdThreshold" min="-1000" max="500" step="5" value="0">
                    </div>
                </div>
            </div>

            <div class="panel-section" data-indicator="kd">
                <h3>ğŸ“Š KD æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>è¶…è³£å€åŸŸ (Kå€¼ä½æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="kdThresholdRange" class="kd-range" min="0" max="80" step="1"
                                    value="30">
                            </div>
                            <div class="range-labels">
                                <span>0</span>
                                <span>80</span>
                            </div>
                        </div>
                        <input type="number" id="kdThreshold" min="0" max="80" step="1" value="30">
                    </div>
                </div>
            </div>

            <div class="panel-section" data-indicator="rsi">
                <h3>ğŸ“ˆ RSI æŒ‡æ¨™è¨­å®š</h3>
                <div class="range-input">
                    <label>è¶…è³£å€åŸŸ (ä½æ–¼):</label>
                    <div class="range-control">
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper">
                                <input type="range" id="rsiThresholdRange" class="rsi-range" min="0" max="80" step="1"
                                    value="30">
                            </div>
                            <div class="range-labels rsi-labels">
                                <span>0</span>
                                <span>80</span>
                            </div>
                        </div>
                        <input type="number" id="rsiThreshold" min="0" max="80" step="1" value="30">
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>ğŸ¯ Kç·šå€è¤‡åˆæ¨™è¨˜</h3>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="compositeMACD" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="compositeMACD">æ¡ç”¨ MACD æ¢ä»¶</label>
                </div>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="compositeKD" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="compositeKD">æ¡ç”¨ KD æ¢ä»¶</label>
                </div>
                <div class="zone-checkbox">
                    <label class="toggle-switch">
                        <input type="checkbox" id="compositeRSI" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <label for="compositeRSI">æ¡ç”¨ RSI æ¢ä»¶</label>
                </div>
            </div>
        </div>
    </div>

    <!-- å‡ç·šè¨­å®šæµ®å‹•æ§åˆ¶é¢æ¿ -->
    <div class="floating-panel" id="maSettingsPanel">
        <button class="panel-toggle" id="maSettingsPanelToggle">âš™ï¸</button>
        <div class="panel-content">
            <div class="panel-section">
                <h3>ğŸ“ˆ ç§»å‹•å¹³å‡ç·šè¨­å®š</h3>
                <p style="font-size: 0.85em; color: var(--text-muted); margin: 0 0 12px 0;">
                    è‡ªè¨‚æ¯æ¢MAçš„é€±æœŸæ•¸å’Œé¡è‰²
                </p>
            </div>

            <!-- MA1 è¨­å®š -->
            <div class="panel-section ma-setting-item">
                <div class="ma-setting-header">
                    <label class="toggle-switch">
                        <input type="checkbox" id="ma1Enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="ma-label">MA</span>
                    <input type="number" id="ma1Period" class="ma-period-input" min="1" max="200" value="5">
                </div>
                <div class="ma-color-row">
                    <label>é¡è‰²ï¼š</label>
                    <input type="color" id="ma1Color" class="ma-color-input" value="#FFBF00">
                    <span class="ma-color-preview" id="ma1ColorPreview" style="background-color: #FFBF00;"></span>
                </div>
            </div>

            <!-- MA2 è¨­å®š -->
            <div class="panel-section ma-setting-item">
                <div class="ma-setting-header">
                    <label class="toggle-switch">
                        <input type="checkbox" id="ma2Enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="ma-label">MA</span>
                    <input type="number" id="ma2Period" class="ma-period-input" min="1" max="200" value="10">
                </div>
                <div class="ma-color-row">
                    <label>é¡è‰²ï¼š</label>
                    <input type="color" id="ma2Color" class="ma-color-input" value="#8A2BE2">
                    <span class="ma-color-preview" id="ma2ColorPreview" style="background-color: #8A2BE2;"></span>
                </div>
            </div>

            <!-- MA3 è¨­å®š -->
            <div class="panel-section ma-setting-item">
                <div class="ma-setting-header">
                    <label class="toggle-switch">
                        <input type="checkbox" id="ma3Enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="ma-label">MA</span>
                    <input type="number" id="ma3Period" class="ma-period-input" min="1" max="200" value="20">
                </div>
                <div class="ma-color-row">
                    <label>é¡è‰²ï¼š</label>
                    <input type="color" id="ma3Color" class="ma-color-input" value="#32CD32">
                    <span class="ma-color-preview" id="ma3ColorPreview" style="background-color: #32CD32;"></span>
                </div>
            </div>

            <!-- MA4 è¨­å®š -->
            <div class="panel-section ma-setting-item">
                <div class="ma-setting-header">
                    <label class="toggle-switch">
                        <input type="checkbox" id="ma4Enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="ma-label">MA</span>
                    <input type="number" id="ma4Period" class="ma-period-input" min="1" max="200" value="40">
                </div>
                <div class="ma-color-row">
                    <label>é¡è‰²ï¼š</label>
                    <input type="color" id="ma4Color" class="ma-color-input" value="#FF6347">
                    <span class="ma-color-preview" id="ma4ColorPreview" style="background-color: #FF6347;"></span>
                </div>
            </div>

            <!-- MA5 è¨­å®š -->
            <div class="panel-section ma-setting-item">
                <div class="ma-setting-header">
                    <label class="toggle-switch">
                        <input type="checkbox" id="ma5Enabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="ma-label">MA</span>
                    <input type="number" id="ma5Period" class="ma-period-input" min="1" max="200" value="60">
                </div>
                <div class="ma-color-row">
                    <label>é¡è‰²ï¼š</label>
                    <input type="color" id="ma5Color" class="ma-color-input" value="#FF1493">
                    <span class="ma-color-preview" id="ma5ColorPreview" style="background-color: #FF1493;"></span>
                </div>
            </div>

            <div class="panel-section">
                <button id="applyMaSettings" class="master-toggle active">å¥—ç”¨è¨­å®š</button>
            </div>
        </div>
    </div>

    <script>
        // --- 0. è¨­å®š Day.js ---
        dayjs.extend(window.dayjs_plugin_weekOfYear);

        // --- 0.1 ä¸»é¡Œåˆ‡æ›åŠŸèƒ½ ---
        (function () {
            const themeToggle = document.getElementById('themeToggle');
            const themeIcon = document.querySelector('.theme-icon');
            const themeText = document.querySelector('.theme-text');

            // å¾ localStorage æˆ–ç³»çµ±åå¥½æª¢æ¸¬åˆå§‹ä¸»é¡Œ
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');

            // æ‡‰ç”¨åˆå§‹ä¸»é¡Œ
            function applyTheme(theme) {
                if (theme === 'light') {
                    document.documentElement.setAttribute('data-theme', 'light');
                    themeToggle.checked = true;
                    themeIcon.textContent = 'â˜€ï¸';
                    themeText.textContent = 'æ·ºè‰²';
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    themeToggle.checked = false;
                    themeIcon.textContent = 'ğŸŒ™';
                    themeText.textContent = 'æ·±è‰²';
                }
                localStorage.setItem('theme', theme);
            }

            // åˆå§‹åŒ–ä¸»é¡Œ
            applyTheme(initialTheme);

            // ç›£è½åˆ‡æ›äº‹ä»¶
            themeToggle.addEventListener('change', () => {
                const newTheme = themeToggle.checked ? 'light' : 'dark';
                applyTheme(newTheme);
            });
        })();

        // --- 1. [Utils] æ•¸å­¸è¨ˆç®—å·¥å…· (æ¡ç”¨SMAé ç†±ï¼Œå‘½åèˆ‡æ¨¹ç²¾éˆåŒæ­¥) ---
        const TechUtils = {
            calculateSMA: (data, period) => {
                if (!data || data.length < period) {
                    return new Array(data.length).fill(null);
                }
                const smaArray = new Array(data.length).fill(null);
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i];
                    if (i >= period) {
                        sum -= data[i - period];
                        smaArray[i] = sum / period;
                    } else if (i === period - 1) {
                        smaArray[i] = sum / period;
                    }
                }
                return smaArray;
            },

            calculateEMA: (data, period) => {
                if (!data || data.length < period) {
                    return new Array(data.length).fill(null);
                }

                const k = 2 / (period + 1);
                const emaArray = new Array(data.length).fill(null);

                let sma = 0;
                for (let i = 0; i < period; i++) {
                    sma += data[i];
                }
                emaArray[period - 1] = sma / period;

                for (let i = period; i < data.length; i++) {
                    emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
                }

                return emaArray;
            },

            calculateMACD: (closePrices, shortPeriod = 12, longPeriod = 26, midPeriod = 9) => {
                const totalLength = closePrices.length;
                if (totalLength < longPeriod + midPeriod - 1) {
                    return { dif: [], macd: [], dm: [] };
                }

                const shortEMA = TechUtils.calculateEMA(closePrices, shortPeriod);
                const longEMA = TechUtils.calculateEMA(closePrices, longPeriod);

                const dif = new Array(totalLength).fill(null);
                for (let i = longPeriod - 1; i < totalLength; i++) {
                    if (longEMA[i] !== null && shortEMA[i] !== null) {
                        dif[i] = shortEMA[i] - longEMA[i];
                    }
                }

                const difValues = dif.slice(longPeriod - 1);
                const macdValues = TechUtils.calculateEMA(difValues, midPeriod);

                const macd = new Array(totalLength).fill(null);
                for (let i = 0; i < macdValues.length; i++) {
                    if (macdValues[i] !== null) {
                        macd[i + longPeriod - 1] = macdValues[i];
                    }
                }

                const dm = new Array(totalLength).fill(null);
                const startIndex = longPeriod - 1 + midPeriod - 1;
                for (let i = startIndex; i < totalLength; i++) {
                    if (dif[i] !== null && macd[i] !== null) {
                        dm[i] = dif[i] - macd[i];
                    }
                }

                return { dif, macd, dm };
            },

            calculateKD: (data, kPeriod = 9, dPeriod = 3) => {
                const totalLength = data.length;
                if (totalLength < kPeriod) {
                    return { k: [], d: [] };
                }

                const rsvArray = new Array(totalLength).fill(null);

                for (let i = kPeriod - 1; i < totalLength; i++) {
                    let highestHigh = -Infinity;
                    let lowestLow = Infinity;

                    for (let j = i - kPeriod + 1; j <= i; j++) {
                        if (data[j].high > highestHigh) highestHigh = data[j].high;
                        if (data[j].low < lowestLow) lowestLow = data[j].low;
                    }

                    const range = highestHigh - lowestLow;
                    if (range !== 0) {
                        rsvArray[i] = ((data[i].close - lowestLow) / range) * 100;
                    } else {
                        rsvArray[i] = 50;
                    }
                }

                const kArray = new Array(totalLength).fill(null);
                kArray[kPeriod - 1] = rsvArray[kPeriod - 1];

                for (let i = kPeriod; i < totalLength; i++) {
                    if (rsvArray[i] !== null && kArray[i - 1] !== null) {
                        kArray[i] = (kArray[i - 1] * 2 / 3) + (rsvArray[i] * 1 / 3);
                    }
                }

                const dArray = new Array(totalLength).fill(null);
                dArray[kPeriod - 1] = kArray[kPeriod - 1];

                for (let i = kPeriod; i < totalLength; i++) {
                    if (kArray[i] !== null && dArray[i - 1] !== null) {
                        dArray[i] = (dArray[i - 1] * 2 / 3) + (kArray[i] * 1 / 3);
                    }
                }

                return { k: kArray, d: dArray };
            },

            calculateRSI: (closePrices, period = 14) => {
                const totalLength = closePrices.length;
                if (totalLength < period + 1) {
                    return new Array(totalLength).fill(null);
                }

                const rsiArray = new Array(totalLength).fill(null);
                let avgGain = 0;
                let avgLoss = 0;

                for (let i = 1; i <= period; i++) {
                    const change = closePrices[i] - closePrices[i - 1];
                    if (change > 0) {
                        avgGain += change;
                    } else {
                        avgLoss += Math.abs(change);
                    }
                }
                avgGain /= period;
                avgLoss /= period;

                if (avgLoss === 0) {
                    rsiArray[period] = 100;
                } else {
                    const rs = avgGain / avgLoss;
                    rsiArray[period] = 100 - (100 / (1 + rs));
                }

                for (let i = period + 1; i < totalLength; i++) {
                    const change = closePrices[i] - closePrices[i - 1];
                    const gain = change > 0 ? change : 0;
                    const loss = change < 0 ? Math.abs(change) : 0;

                    avgGain = (avgGain * (period - 1) + gain) / period;
                    avgLoss = (avgLoss * (period - 1) + loss) / period;

                    if (avgLoss === 0) {
                        rsiArray[i] = 100;
                    } else {
                        const rs = avgGain / avgLoss;
                        rsiArray[i] = 100 - (100 / (1 + rs));
                    }
                }

                return rsiArray;
            }
        };

        // --- 2. [Service] è³‡æ–™è™•ç†å±¤ (æ”¹ç‚ºä¸²æ¥çœŸå¯¦ API) ---
        const DataService = {
            fetchRealData: async () => {
                const API_URL = 'https://api.finmindtrade.com/api/v4/data?dataset=TaiwanStockPrice&data_id=TAIEX&start_date=1997-01-01';
                try {
                    const response = await fetch(API_URL);
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const result = await response.json();
                    if (result.data && result.data.length > 0) {
                        return result.data.map(item => ({
                            date: item.date,
                            open: item.open,
                            high: item.max,
                            low: item.min,
                            close: item.close,
                            values: [item.open, item.close, item.min, item.max]
                        }));
                    } else {
                        throw new Error('No data received from API');
                    }
                } catch (error) {
                    console.error("Failed to fetch real data:", error);
                    return [];
                }
            },

            resampleToPeriod: (dailyData, periodType) => {
                if (periodType === 'daily') {
                    return dailyData.map(d => ({ ...d, date: d.date }));
                }

                const grouped = {};
                dailyData.forEach(tick => {
                    const d = dayjs(tick.date);
                    let key;
                    switch (periodType) {
                        case 'weekly':
                            key = `${d.year()}-W${String(d.week()).padStart(2, '0')}`;
                            break;
                        case 'bi-weekly':
                            const biWeekIndex = Math.floor(d.week() / 2);
                            key = `${d.year()}-BW${String(biWeekIndex).padStart(2, '0')}`;
                            break;
                        case 'tri-weekly':
                            const triWeekIndex = Math.floor(d.week() / 3);
                            key = `${d.year()}-TW${String(triWeekIndex).padStart(2, '0')}`;
                            break;
                        case 'monthly':
                            key = d.format('YYYY-MM');
                            break;
                    }

                    if (!grouped[key]) grouped[key] = [];
                    grouped[key].push(tick);
                });

                return Object.keys(grouped).sort().map(key => {
                    const ticks = grouped[key];
                    const firstTick = ticks[0];
                    const lastTick = ticks[ticks.length - 1];

                    const open = firstTick.open;
                    const close = lastTick.close;
                    const high = Math.max(...ticks.map(t => t.high));
                    const low = Math.min(...ticks.map(t => t.low));

                    const displayDate = `${firstTick.date} ~ ${lastTick.date}`;

                    return {
                        date: displayDate,
                        open,
                        close,
                        high,
                        low,
                        values: [open, close, low, high]
                    };
                });
            }
        };

        // --- 3. [View] æ¸²æŸ“å±¤ (æ”¹ç‚ºéåŒæ­¥ async function) ---
        async function initApp() {
            const statusEl = document.getElementById('status');
            const chartTitleEl = document.getElementById('chart-title');
            const chartDom = document.getElementById('chart');
            const myChart = echarts.init(chartDom);
            const controlButtons = document.querySelectorAll('.btn');

            // MA é…ç½®ç‹€æ…‹
            const maConfig = [
                { enabled: true, period: 5, color: '#FFBF00' },
                { enabled: true, period: 10, color: '#8A2BE2' },
                { enabled: true, period: 20, color: '#32CD32' },
                { enabled: true, period: 40, color: '#FF6347' },
                { enabled: true, period: 60, color: '#FF1493' }
            ];

            // å‹•æ…‹ç”Ÿæˆ LINE_COLORS
            function getLineColors() {
                const colors = {
                    DIF: '#DA6EE8',
                    MACD: '#00D5FA',
                    K: '#FF6B6B',
                    D: '#4ECDC4',
                    RSI5: '#FF8C00',
                    RSI10: '#9370DB'
                };
                maConfig.forEach((ma, idx) => {
                    colors[`MA${idx + 1}`] = ma.color;
                });
                return colors;
            }

            let LINE_COLORS = getLineColors();

            // æµ®å‹•é¢æ¿æ§åˆ¶
            const macdReversalPanel = document.getElementById('macdReversalPanel');
            const highPricePanel = document.getElementById('highPricePanel');
            const lowPricePanel = document.getElementById('lowPricePanel');
            const maSettingsPanel = document.getElementById('maSettingsPanel');
            const macdReversalPanelToggle = document.getElementById('macdReversalPanelToggle');
            const highPanelToggle = document.getElementById('highPanelToggle');
            const lowPanelToggle = document.getElementById('lowPanelToggle');
            const maSettingsPanelToggle = document.getElementById('maSettingsPanelToggle');
            const macdReversalBookmark = document.getElementById('macdReversalBookmark');
            const highPriceAreaBookmark = document.getElementById('highPriceAreaBookmark');
            const lowPriceAreaBookmark = document.getElementById('lowPriceAreaBookmark');
            const maSettingsBookmark = document.getElementById('maSettingsBookmark');
            const sidebar = document.querySelector('.sidebar');

            // é—œé–‰æ‰€æœ‰é¢æ¿
            function closeAllPanels() {
                macdReversalPanel.classList.remove('open');
                highPricePanel.classList.remove('open');
                lowPricePanel.classList.remove('open');
                maSettingsPanel.classList.remove('open');
                sidebar.classList.remove('panel-open');
                macdReversalBookmark.classList.remove('active');
                highPriceAreaBookmark.classList.remove('active');
                lowPriceAreaBookmark.classList.remove('active');
                maSettingsBookmark.classList.remove('active');
            }

            // åˆ‡æ›MACDåè½‰é¢æ¿
            function toggleMacdReversalPanel() {
                const wasOpen = macdReversalPanel.classList.contains('open');
                closeAllPanels();
                if (!wasOpen) {
                    macdReversalPanel.classList.add('open');
                    sidebar.classList.add('panel-open');
                    macdReversalBookmark.classList.add('active');
                }
            }

            // åˆ‡æ›é«˜æª”å€åŸŸé¢æ¿
            function toggleHighPanel() {
                const wasOpen = highPricePanel.classList.contains('open');
                closeAllPanels();
                if (!wasOpen) {
                    highPricePanel.classList.add('open');
                    sidebar.classList.add('panel-open');
                    highPriceAreaBookmark.classList.add('active');
                }
            }

            // åˆ‡æ›ä½æª”å€åŸŸé¢æ¿
            function toggleLowPanel() {
                const wasOpen = lowPricePanel.classList.contains('open');
                closeAllPanels();
                if (!wasOpen) {
                    lowPricePanel.classList.add('open');
                    sidebar.classList.add('panel-open');
                    lowPriceAreaBookmark.classList.add('active');
                }
            }

            // åˆ‡æ›å‡ç·šè¨­å®šé¢æ¿
            function toggleMaSettingsPanel() {
                const wasOpen = maSettingsPanel.classList.contains('open');
                closeAllPanels();
                if (!wasOpen) {
                    maSettingsPanel.classList.add('open');
                    sidebar.classList.add('panel-open');
                    maSettingsBookmark.classList.add('active');
                }
            }

            // ç¶å®šMACDåè½‰æ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
            macdReversalPanelToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMacdReversalPanel();
            });

            macdReversalBookmark.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMacdReversalPanel();
            });

            // ç¶å®šé«˜æª”å€åŸŸæ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
            highPanelToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleHighPanel();
            });

            highPriceAreaBookmark.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleHighPanel();
            });

            // ç¶å®šä½æª”å€åŸŸæ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
            lowPanelToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleLowPanel();
            });

            lowPriceAreaBookmark.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleLowPanel();
            });

            // ç¶å®šå‡ç·šè¨­å®šæ›¸ç±¤å’Œé¢æ¿åˆ‡æ›æŒ‰éˆ•
            maSettingsPanelToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMaSettingsPanel();
            });

            maSettingsBookmark.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMaSettingsPanel();
            });

            // é»æ“Šé¢æ¿å¤–éƒ¨é—œé–‰é¢æ¿
            document.addEventListener('click', (e) => {
                const isClickInsideMacdReversalPanel = macdReversalPanel.contains(e.target);
                const isClickInsideHighPanel = highPricePanel.contains(e.target);
                const isClickInsideLowPanel = lowPricePanel.contains(e.target);
                const isClickInsideMaSettingsPanel = maSettingsPanel.contains(e.target);
                const isClickOnSidebar = sidebar.contains(e.target);
                const isAnyPanelOpen = macdReversalPanel.classList.contains('open') || highPricePanel.classList.contains('open') || lowPricePanel.classList.contains('open') || maSettingsPanel.classList.contains('open');

                // å¦‚æœæœ‰é¢æ¿æ˜¯é–‹å•Ÿçš„ï¼Œä¸”é»æ“Šä¸åœ¨ä»»ä½•é¢æ¿å…§ï¼Œä¹Ÿä¸åœ¨å´é‚Šæ¬„ä¸Šï¼Œå‰‡é—œé–‰æ‰€æœ‰é¢æ¿
                if (isAnyPanelOpen && !isClickInsideMacdReversalPanel && !isClickInsideHighPanel && !isClickInsideLowPanel && !isClickInsideMaSettingsPanel && !isClickOnSidebar) {
                    closeAllPanels();
                }
            });

            // é˜²æ­¢é»æ“Šé¢æ¿å…§éƒ¨æ™‚é—œé–‰é¢æ¿
            macdReversalPanel.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            highPricePanel.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            lowPricePanel.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            maSettingsPanel.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // å€åŸŸæ¨™è¨˜ç‹€æ…‹ç®¡ç†
            let zoneMarkingState = {
                masterEnabled: false,  // é è¨­é—œé–‰ä½æª”æ¨™è¨˜
                kd: { enabled: true, threshold: 30 },
                rsi: { enabled: true, threshold: 30 },
                macd: { enabled: true, threshold: 0 },
                composite: {
                    useKD: true,
                    useRSI: true,
                    useMACD: true
                },
                // é«˜æª”å€åŸŸæ¨™è¨˜
                highMasterEnabled: false,  // é è¨­é—œé–‰é«˜æª”æ¨™è¨˜
                highKd: { enabled: true, threshold: 70 },
                highRsi: { enabled: true, threshold: 70 },
                highMacd: { enabled: true, threshold: 0 },
                highComposite: {
                    useKD: true,
                    useRSI: true,
                    useMACD: true
                },
                // MACDè²·è³£é»æ¨™è¨˜
                macdBuySell: {
                    masterEnabled: false,  // è²·è³£é»ç¸½é–‹é—œï¼ˆé è¨­é—œé–‰ï¼‰
                    sellEnabled: true,     // é è¨­é–‹å•Ÿè³£é»æ¨™è¨˜
                    buyEnabled: true,      // é è¨­é–‹å•Ÿè²·é»æ¨™è¨˜
                    sellThreshold: 0,      // è³£é»é–¾å€¼ï¼ˆæ­£å€¼åè½‰ï¼‰
                    buyThreshold: 0        // è²·é»é–¾å€¼ï¼ˆè² å€¼åè½‰ï¼‰
                }
            };

            statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: #3498db;">æ­£åœ¨å¾ FinMind API ç²å–çœŸå¯¦å°è‚¡åŠ æ¬ŠæŒ‡æ•¸æ­·å²è³‡æ–™...</span>`;

            console.time("FetchRealData");
            const dailyData = await DataService.fetchRealData();
            console.timeEnd("FetchRealData");

            if (dailyData.length === 0) {
                statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼š<span style="color: red;">ç²å–çœŸå¯¦è³‡æ–™å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚åœ–è¡¨ç„¡æ³•è¼‰å…¥ã€‚</span>`;
                return;
            }

            statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šçœŸå¯¦è³‡æ–™è¼‰å…¥æˆåŠŸï¼Œè«‹é¸æ“‡æ™‚é–“é€±æœŸã€‚`;

            let currentPeriod = 'daily';
            let lastClickedIndex = null; // ç”¨æ–¼è¿½è¹¤é»æ“Šçš„Kæ£’ï¼Œå¯¦ç¾åå­—ç·šåˆ‡æ›
            let isMultiCrosshairMode = false;
            let multiCrosshairPoints = [];
            let indicatorVisible = {
                macd: true,
                kd: true,
                rsi: true
            };

            // ä¸»é–‹é—œæ§åˆ¶
            const masterToggle = document.getElementById('masterToggle');
            masterToggle.addEventListener('change', () => {
                zoneMarkingState.masterEnabled = masterToggle.checked;
                updateChartMarkingsOnly();
            });

            // KD è¨­å®šæ§åˆ¶
            const kdThresholdRange = document.getElementById('kdThresholdRange');
            const kdThresholdInput = document.getElementById('kdThreshold');

            // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
            kdThresholdRange.addEventListener('input', () => {
                const value = parseInt(kdThresholdRange.value);
                kdThresholdInput.value = value;
                zoneMarkingState.kd.threshold = value;
                updateChartMarkingsOnly();
            });

            kdThresholdInput.addEventListener('input', () => {
                let value = parseInt(kdThresholdInput.value);
                // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
                if (isNaN(value)) value = 30;
                value = Math.max(0, Math.min(80, value));
                // èª¿æ•´ç‚ºæ•´æ•¸
                value = Math.round(value);
                kdThresholdInput.value = value;
                kdThresholdRange.value = value;
                zoneMarkingState.kd.threshold = value;
                updateChartMarkingsOnly();
            });

            kdThresholdInput.addEventListener('blur', () => {
                // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
                let value = parseInt(kdThresholdInput.value);
                if (isNaN(value)) value = 30;
                value = Math.max(0, Math.min(80, value));
                value = Math.round(value);
                kdThresholdInput.value = value;
                kdThresholdRange.value = value;
                zoneMarkingState.kd.threshold = value;
                updateChartMarkingsOnly();
            });

            // RSI è¨­å®šæ§åˆ¶
            const rsiThresholdRange = document.getElementById('rsiThresholdRange');
            const rsiThresholdInput = document.getElementById('rsiThreshold');

            // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
            rsiThresholdRange.addEventListener('input', () => {
                const value = parseInt(rsiThresholdRange.value);
                rsiThresholdInput.value = value;
                zoneMarkingState.rsi.threshold = value;
                updateChartMarkingsOnly();
            });

            rsiThresholdInput.addEventListener('input', () => {
                let value = parseInt(rsiThresholdInput.value);
                // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
                if (isNaN(value)) value = 30;
                value = Math.max(0, Math.min(80, value));
                // èª¿æ•´ç‚ºæ•´æ•¸
                value = Math.round(value);
                rsiThresholdInput.value = value;
                rsiThresholdRange.value = value;
                zoneMarkingState.rsi.threshold = value;
                updateChartMarkingsOnly();
            });

            rsiThresholdInput.addEventListener('blur', () => {
                // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
                let value = parseInt(rsiThresholdInput.value);
                if (isNaN(value)) value = 30;
                value = Math.max(0, Math.min(80, value));
                value = Math.round(value);
                rsiThresholdInput.value = value;
                rsiThresholdRange.value = value;
                zoneMarkingState.rsi.threshold = value;
                updateChartMarkingsOnly();
            });

            // MACD è¨­å®šæ§åˆ¶
            const macdThresholdRange = document.getElementById('macdThresholdRange');
            const macdThresholdInput = document.getElementById('macdThreshold');

            // åŒæ­¥æ»‘å‹•æ¢å’Œè¼¸å…¥æ¡†
            macdThresholdRange.addEventListener('input', () => {
                const value = parseInt(macdThresholdRange.value);
                macdThresholdInput.value = value;
                zoneMarkingState.macd.threshold = value;
                updateChartMarkingsOnly();
            });

            macdThresholdInput.addEventListener('input', () => {
                let value = parseInt(macdThresholdInput.value);
                // ç¢ºä¿å€¼åœ¨ç¯„åœå…§ä¸”ç‚ºæ•´æ•¸
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(500, value));
                // èª¿æ•´ç‚ºæ­¥é€²å€¼çš„å€æ•¸ (5)
                value = Math.round(value / 5) * 5;
                macdThresholdInput.value = value;
                macdThresholdRange.value = value;
                zoneMarkingState.macd.threshold = value;
                updateChartMarkingsOnly();
            });

            macdThresholdInput.addEventListener('blur', () => {
                // å¤±å»ç„¦é»æ™‚ç¢ºä¿å€¼æœ‰æ•ˆ
                let value = parseInt(macdThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(500, value));
                value = Math.round(value / 5) * 5;
                macdThresholdInput.value = value;
                macdThresholdRange.value = value;
                zoneMarkingState.macd.threshold = value;
                updateChartMarkingsOnly();
            });

            // è¤‡åˆæ¨™è¨˜æ§åˆ¶
            const compositeKD = document.getElementById('compositeKD');
            const compositeRSI = document.getElementById('compositeRSI');
            const compositeMACD = document.getElementById('compositeMACD');

            // ç²å–å°æ‡‰çš„é¢æ¿å€å¡Šï¼ˆé™å®šåœ¨ä½æª”å€åŸŸé¢æ¿å…§ï¼‰
            const kdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="kd"]');
            const rsiPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="rsi"]');
            const macdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="macd"]');

            compositeKD.addEventListener('change', () => {
                zoneMarkingState.composite.useKD = compositeKD.checked;
                // æ§åˆ¶ KD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                if (compositeKD.checked) {
                    kdPanelSection.classList.remove('hidden');
                } else {
                    kdPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });
            compositeRSI.addEventListener('change', () => {
                zoneMarkingState.composite.useRSI = compositeRSI.checked;
                // æ§åˆ¶ RSI è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                if (compositeRSI.checked) {
                    rsiPanelSection.classList.remove('hidden');
                } else {
                    rsiPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });
            compositeMACD.addEventListener('change', () => {
                zoneMarkingState.composite.useMACD = compositeMACD.checked;
                // æ§åˆ¶ MACD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                if (compositeMACD.checked) {
                    macdPanelSection.classList.remove('hidden');
                } else {
                    macdPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });

            // === é«˜æª”å€åŸŸæ§åˆ¶ ===

            // é«˜æª”ä¸»é–‹é—œæ§åˆ¶
            const highMasterToggle = document.getElementById('highMasterToggle');
            highMasterToggle.addEventListener('change', () => {
                zoneMarkingState.highMasterEnabled = highMasterToggle.checked;
                updateChartMarkingsOnly();
            });

            // é«˜æª” KD è¨­å®šæ§åˆ¶
            const highKdThresholdRange = document.getElementById('highKdThresholdRange');
            const highKdThresholdInput = document.getElementById('highKdThreshold');

            highKdThresholdRange.addEventListener('input', () => {
                const value = parseInt(highKdThresholdRange.value);
                highKdThresholdInput.value = value;
                zoneMarkingState.highKd.threshold = value;
                updateChartMarkingsOnly();
            });

            highKdThresholdInput.addEventListener('input', () => {
                let value = parseInt(highKdThresholdInput.value);
                if (isNaN(value)) value = 70;
                value = Math.max(20, Math.min(100, value));
                value = Math.round(value);
                highKdThresholdInput.value = value;
                highKdThresholdRange.value = value;
                zoneMarkingState.highKd.threshold = value;
                updateChartMarkingsOnly();
            });

            highKdThresholdInput.addEventListener('blur', () => {
                let value = parseInt(highKdThresholdInput.value);
                if (isNaN(value)) value = 70;
                value = Math.max(20, Math.min(100, value));
                value = Math.round(value);
                highKdThresholdInput.value = value;
                highKdThresholdRange.value = value;
                zoneMarkingState.highKd.threshold = value;
                updateChartMarkingsOnly();
            });

            // é«˜æª” RSI è¨­å®šæ§åˆ¶
            const highRsiThresholdRange = document.getElementById('highRsiThresholdRange');
            const highRsiThresholdInput = document.getElementById('highRsiThreshold');

            highRsiThresholdRange.addEventListener('input', () => {
                const value = parseInt(highRsiThresholdRange.value);
                highRsiThresholdInput.value = value;
                zoneMarkingState.highRsi.threshold = value;
                updateChartMarkingsOnly();
            });

            highRsiThresholdInput.addEventListener('input', () => {
                let value = parseInt(highRsiThresholdInput.value);
                if (isNaN(value)) value = 70;
                value = Math.max(20, Math.min(100, value));
                value = Math.round(value);
                highRsiThresholdInput.value = value;
                highRsiThresholdRange.value = value;
                zoneMarkingState.highRsi.threshold = value;
                updateChartMarkingsOnly();
            });

            highRsiThresholdInput.addEventListener('blur', () => {
                let value = parseInt(highRsiThresholdInput.value);
                if (isNaN(value)) value = 70;
                value = Math.max(20, Math.min(100, value));
                value = Math.round(value);
                highRsiThresholdInput.value = value;
                highRsiThresholdRange.value = value;
                zoneMarkingState.highRsi.threshold = value;
                updateChartMarkingsOnly();
            });

            // é«˜æª” MACD è¨­å®šæ§åˆ¶
            const highMacdThresholdRange = document.getElementById('highMacdThresholdRange');
            const highMacdThresholdInput = document.getElementById('highMacdThreshold');

            highMacdThresholdRange.addEventListener('input', () => {
                const value = parseInt(highMacdThresholdRange.value);
                highMacdThresholdInput.value = value;
                zoneMarkingState.highMacd.threshold = value;
                updateChartMarkingsOnly();
            });

            highMacdThresholdInput.addEventListener('input', () => {
                let value = parseInt(highMacdThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-500, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                highMacdThresholdInput.value = value;
                highMacdThresholdRange.value = value;
                zoneMarkingState.highMacd.threshold = value;
                updateChartMarkingsOnly();
            });

            highMacdThresholdInput.addEventListener('blur', () => {
                let value = parseInt(highMacdThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-500, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                highMacdThresholdInput.value = value;
                highMacdThresholdRange.value = value;
                zoneMarkingState.highMacd.threshold = value;
                updateChartMarkingsOnly();
            });

            // é«˜æª”è¤‡åˆæ¨™è¨˜æ§åˆ¶
            const highCompositeKD = document.getElementById('highCompositeKD');
            const highCompositeRSI = document.getElementById('highCompositeRSI');
            const highCompositeMACD = document.getElementById('highCompositeMACD');

            const highKdPanelSection = document.getElementById('highKdSection');
            const highRsiPanelSection = document.getElementById('highRsiSection');
            const highMacdPanelSection = document.getElementById('highMacdSection');

            highCompositeKD.addEventListener('change', () => {
                zoneMarkingState.highComposite.useKD = highCompositeKD.checked;
                if (highCompositeKD.checked) {
                    highKdPanelSection.classList.remove('hidden');
                } else {
                    highKdPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });

            highCompositeRSI.addEventListener('change', () => {
                zoneMarkingState.highComposite.useRSI = highCompositeRSI.checked;
                if (highCompositeRSI.checked) {
                    highRsiPanelSection.classList.remove('hidden');
                } else {
                    highRsiPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });

            highCompositeMACD.addEventListener('change', () => {
                zoneMarkingState.highComposite.useMACD = highCompositeMACD.checked;
                if (highCompositeMACD.checked) {
                    highMacdPanelSection.classList.remove('hidden');
                } else {
                    highMacdPanelSection.classList.add('hidden');
                }
                updateChartMarkingsOnly();
            });

            // === MACDè²·è³£é»æ§åˆ¶ ===
            const macdBuySellMasterToggle = document.getElementById('macdBuySellMasterToggle');
            const macdSellToggle = document.getElementById('macdSellToggle');
            const macdBuyToggle = document.getElementById('macdBuyToggle');
            const macdSellThresholdRange = document.getElementById('macdSellThresholdRange');
            const macdSellThresholdInput = document.getElementById('macdSellThreshold');
            const macdBuyThresholdRange = document.getElementById('macdBuyThresholdRange');
            const macdBuyThresholdInput = document.getElementById('macdBuyThreshold');

            // è²·è³£é»ç¸½é–‹é—œ
            macdBuySellMasterToggle.addEventListener('change', () => {
                zoneMarkingState.macdBuySell.masterEnabled = macdBuySellMasterToggle.checked;
                updateChartMarkingsOnly();
            });

            // è³£é»é–‹é—œ
            macdSellToggle.addEventListener('change', () => {
                zoneMarkingState.macdBuySell.sellEnabled = macdSellToggle.checked;
                updateChartMarkingsOnly();
            });

            // è²·é»é–‹é—œ
            macdBuyToggle.addEventListener('change', () => {
                zoneMarkingState.macdBuySell.buyEnabled = macdBuyToggle.checked;
                updateChartMarkingsOnly();
            });

            // è³£é»é–¾å€¼æ§åˆ¶
            macdSellThresholdRange.addEventListener('input', () => {
                const value = parseInt(macdSellThresholdRange.value);
                macdSellThresholdInput.value = value;
                zoneMarkingState.macdBuySell.sellThreshold = value;
                updateChartMarkingsOnly();
            });

            macdSellThresholdInput.addEventListener('input', () => {
                let value = parseInt(macdSellThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                macdSellThresholdInput.value = value;
                macdSellThresholdRange.value = value;
                zoneMarkingState.macdBuySell.sellThreshold = value;
                updateChartMarkingsOnly();
            });

            macdSellThresholdInput.addEventListener('blur', () => {
                let value = parseInt(macdSellThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                macdSellThresholdInput.value = value;
                macdSellThresholdRange.value = value;
                zoneMarkingState.macdBuySell.sellThreshold = value;
                updateChartMarkingsOnly();
            });

            // è²·é»é–¾å€¼æ§åˆ¶
            macdBuyThresholdRange.addEventListener('input', () => {
                const value = parseInt(macdBuyThresholdRange.value);
                macdBuyThresholdInput.value = value;
                zoneMarkingState.macdBuySell.buyThreshold = value;
                updateChartMarkingsOnly();
            });

            macdBuyThresholdInput.addEventListener('input', () => {
                let value = parseInt(macdBuyThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                macdBuyThresholdInput.value = value;
                macdBuyThresholdRange.value = value;
                zoneMarkingState.macdBuySell.buyThreshold = value;
                updateChartMarkingsOnly();
            });

            macdBuyThresholdInput.addEventListener('blur', () => {
                let value = parseInt(macdBuyThresholdInput.value);
                if (isNaN(value)) value = 0;
                value = Math.max(-1000, Math.min(1000, value));
                value = Math.round(value / 5) * 5;
                macdBuyThresholdInput.value = value;
                macdBuyThresholdRange.value = value;
                zoneMarkingState.macdBuySell.buyThreshold = value;
                updateChartMarkingsOnly();
            });

            // === MA è¨­å®šæ§åˆ¶ ===
            // é¡è‰²é è¦½æ›´æ–°
            for (let i = 1; i <= 5; i++) {
                const colorInput = document.getElementById(`ma${i}Color`);
                const colorPreview = document.getElementById(`ma${i}ColorPreview`);
                colorInput.addEventListener('input', () => {
                    colorPreview.style.backgroundColor = colorInput.value;
                });
            }

            // å¥—ç”¨è¨­å®šæŒ‰éˆ•
            const applyMaSettingsBtn = document.getElementById('applyMaSettings');
            applyMaSettingsBtn.addEventListener('click', () => {
                // æ›´æ–° maConfig
                for (let i = 1; i <= 5; i++) {
                    const enabledInput = document.getElementById(`ma${i}Enabled`);
                    const periodInput = document.getElementById(`ma${i}Period`);
                    const colorInput = document.getElementById(`ma${i}Color`);

                    maConfig[i - 1].enabled = enabledInput.checked;
                    maConfig[i - 1].period = parseInt(periodInput.value) || maConfig[i - 1].period;
                    maConfig[i - 1].color = colorInput.value;
                }

                // æ›´æ–° LINE_COLORS
                LINE_COLORS = getLineColors();

                // é‡æ–°ç¹ªè£½åœ–è¡¨
                updateChart(currentPeriod);
            });

            // å„²å­˜ç•¶å‰åœ–è¡¨æ•¸æ“šï¼Œä¾›æ¨™è¨˜æ›´æ–°ä½¿ç”¨
            let currentChartData = null;

            function updateChartMarkingsOnly() {
                if (!currentChartData) return;

                const option = myChart.getOption();
                const newMarkAreas = generateMarkAreas(currentChartData);

                // æ›´æ–°æ‰€æœ‰éœ€è¦æ¨™è¨˜çš„ç³»åˆ—
                option.series.forEach((s, idx) => {
                    if (s.name === currentChartData.periodName) {
                        // Kç·šåœ–çš„è¤‡åˆæ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                        s.markArea = {
                            data: [...newMarkAreas.composite.data, ...newMarkAreas.highComposite.data]
                        };
                        s.markLine = {
                            data: [...newMarkAreas.composite.lines, ...newMarkAreas.highComposite.lines],
                            symbol: 'none',
                            label: { show: false }
                        };
                    } else if (s.name === 'ä½æª”åå½ˆæ”¶ç›¤') {
                        // ğŸ¯ æ©˜è‰²æ¨™è¨˜é»ï¼ˆæ•£é»åœ–ï¼‰
                        s.data = newMarkAreas.postZoneMarkers.data;
                    } else if (s.name === 'é«˜æª”å›è½æ”¶ç›¤') {
                        // ğŸŸ£ ç´«è‰²æ¨™è¨˜é»ï¼ˆæ•£é»åœ–ï¼‰
                        s.data = newMarkAreas.highPostZoneMarkers.data;
                    } else if (s.name === 'è²·é»') {
                        // ğŸ”´ æ·±ç´…è‰²è²·é»ï¼ˆæ•£é»åœ–ï¼‰
                        s.data = (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.buyEnabled)
                            ? newMarkAreas.buySellMarkers.buy : [];
                    } else if (s.name === 'è³£é»') {
                        // ğŸŸ¢ å¢¨ç¶ è‰²è³£é»ï¼ˆæ•£é»åœ–ï¼‰
                        s.data = (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.sellEnabled)
                            ? newMarkAreas.buySellMarkers.sell : [];
                    } else if (s.name === 'K(9)') {
                        // KD çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                        s.markArea = {
                            data: [...newMarkAreas.kd.data, ...newMarkAreas.highKd.data]
                        };
                        s.markLine = {
                            data: [...newMarkAreas.kd.lines, ...newMarkAreas.highKd.lines],
                            symbol: 'none',
                            label: { show: false }
                        };
                    } else if (s.name === 'RSI(5T)') {
                        // RSI çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                        s.markArea = {
                            data: [...newMarkAreas.rsi.data, ...newMarkAreas.highRsi.data]
                        };
                        s.markLine = {
                            data: [...newMarkAreas.rsi.lines, ...newMarkAreas.highRsi.lines],
                            symbol: 'none',
                            label: { show: false }
                        };
                    } else if (s.name === 'DIF') {
                        // MACD çš„æ¨™è¨˜ï¼ˆåŒ…å«ä½æª”å’Œé«˜æª”ï¼‰
                        s.markArea = {
                            data: [...newMarkAreas.macd.data, ...newMarkAreas.highMacd.data]
                        };
                        s.markLine = {
                            data: [...newMarkAreas.macd.lines, ...newMarkAreas.highMacd.lines],
                            symbol: 'none',
                            label: { show: false }
                        };
                    }
                });

                myChart.setOption(option);
            }

            // åªåˆ‡æ›æŒ‡æ¨™é¡¯ç¤º/éš±è—ï¼Œä¸é‡æ–°æ¸²æŸ“åœ–è¡¨ï¼ˆä¿æŒ dataZoom ç‹€æ…‹ï¼‰
            function toggleIndicatorVisibility() {
                if (!currentChartData) return;

                // ç²å–ç•¶å‰çš„ dataZoom ç‹€æ…‹
                const currentOption = myChart.getOption();
                const currentDataZoom = currentOption.dataZoom;

                // å®Œå…¨é‡ç¹ªåœ–è¡¨ï¼ˆå› ç‚ºéœ€è¦èª¿æ•´ grid å’Œ axisï¼‰
                updateChart(currentPeriod);

                // æ¢å¾©ä¹‹å‰çš„ dataZoom ç‹€æ…‹
                setTimeout(() => {
                    myChart.setOption({
                        dataZoom: currentDataZoom
                    });
                }, 0);
            }

            function generateMarkAreas(data) {
                const { resampledData, kdResult, rsi5, macdResult, periodName } = data;

                // ä½æª”å€åŸŸæ¨™è¨˜åˆå§‹åŒ–
                const postZoneMarkers = { data: [] };
                const highPostZoneMarkers = { data: [] };  // é«˜æª”å€åŸŸå¾Œçš„æ¨™è¨˜é»
                let kdMarkAreas = [];
                let kdMarkLines = [];
                let rsiMarkAreas = [];
                let rsiMarkLines = [];
                let macdMarkAreas = [];
                let macdMarkLines = [];
                let compositeMarkAreas = [];
                let compositeMarkLines = [];

                // === ä½æª”å€åŸŸæ¨™è¨˜é‚è¼¯ ===
                if (!zoneMarkingState.masterEnabled) {
                    // ä½æª”æ¨™è¨˜é—œé–‰æ™‚ï¼Œä½¿ç”¨ç©ºé™£åˆ—
                    kdMarkAreas = [];
                    kdMarkLines = [];
                    rsiMarkAreas = [];
                    rsiMarkLines = [];
                    macdMarkAreas = [];
                    macdMarkLines = [];
                    compositeMarkAreas = [];
                    compositeMarkLines = [];
                } else {
                    // ğŸ” æª¢æŸ¥ï¼šå¦‚æœæ‰€æœ‰æŠ€è¡“ç·šåœ–éƒ½é—œé–‰ï¼Œä¸ç”Ÿæˆè¤‡åˆæ¨™è¨˜
                    const hasAnyIndicator = zoneMarkingState.composite.useKD ||
                        zoneMarkingState.composite.useRSI ||
                        zoneMarkingState.composite.useMACD;

                    // KD ä½æª”å€åŸŸæ¨™è¨˜ï¼ˆKå€¼ä½æ–¼é–¾å€¼æ‰æ¨™è¨˜ï¼‰
                    if (indicatorVisible.kd && zoneMarkingState.composite.useKD) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < kdResult.k.length; i++) {
                            const kValue = kdResult.k[i];
                            const dValue = kdResult.d[i];

                            if (kValue !== null && dValue !== null) {
                                // Kå€¼ä½æ–¼é–¾å€¼
                                const isLow = kValue < zoneMarkingState.kd.threshold;

                                if (isLow && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isLow && inZone) {
                                    const zoneEndIndex = i - 1;
                                    // åˆ¤æ–·æ˜¯å–®æ ¹Kæ£’é‚„æ˜¯å€åŸŸ
                                    if (zoneStartIndex === zoneEndIndex) {
                                        // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                        kdMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(255, 215, 0, 0.25)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                        kdMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 215, 0, 0.25)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                kdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 215, 0, 0.25)', width: 2, type: 'solid' }
                                });
                            } else {
                                kdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 215, 0, 0.25)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // RSI ä½æª”å€åŸŸæ¨™è¨˜
                    if (indicatorVisible.rsi && zoneMarkingState.composite.useRSI) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < rsi5.length; i++) {
                            const rsiValue = rsi5[i];

                            if (rsiValue !== null) {
                                const isLow = rsiValue < zoneMarkingState.rsi.threshold;

                                if (isLow && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isLow && inZone) {
                                    const zoneEndIndex = i - 1;
                                    if (zoneStartIndex === zoneEndIndex) {
                                        // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                        rsiMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(147, 112, 219, 0.15)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                        rsiMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(147, 112, 219, 0.15)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                rsiMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(147, 112, 219, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                rsiMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(147, 112, 219, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // MACD ä½æª”å€åŸŸæ¨™è¨˜
                    if (indicatorVisible.macd && zoneMarkingState.composite.useMACD) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < macdResult.dif.length; i++) {
                            const difValue = macdResult.dif[i];

                            if (difValue !== null) {
                                const isLow = difValue < zoneMarkingState.macd.threshold;

                                if (isLow && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isLow && inZone) {
                                    const zoneEndIndex = i - 1;
                                    if (zoneStartIndex === zoneEndIndex) {
                                        // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                        macdMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(0, 213, 250, 0.15)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                        macdMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(0, 213, 250, 0.15)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                macdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(0, 213, 250, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                macdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(0, 213, 250, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // Kç·šå€è¤‡åˆæ¨™è¨˜ (æ‰€æœ‰é¸ä¸­æ¢ä»¶éƒ½æ»¿è¶³çš„å€åŸŸ)
                    // ğŸ” åªæœ‰åœ¨è‡³å°‘æœ‰ä¸€å€‹æŒ‡æ¨™å•Ÿç”¨æ™‚æ‰é€²è¡Œæƒæ
                    if (hasAnyIndicator) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < resampledData.length; i++) {
                            let allConditionsMet = true;

                            // æª¢æŸ¥ KD æ¢ä»¶ï¼ˆKå€¼å¿…é ˆä½æ–¼é–¾å€¼ï¼‰
                            if (zoneMarkingState.composite.useKD) {
                                const kValue = kdResult.k[i];
                                const dValue = kdResult.d[i];
                                if (kValue === null || kValue >= zoneMarkingState.kd.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            // æª¢æŸ¥ RSI æ¢ä»¶
                            if (zoneMarkingState.composite.useRSI) {
                                const rsiValue = rsi5[i];
                                if (rsiValue === null || rsiValue >= zoneMarkingState.rsi.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            // æª¢æŸ¥ MACD æ¢ä»¶
                            if (zoneMarkingState.composite.useMACD) {
                                const difValue = macdResult.dif[i];
                                if (difValue === null || difValue >= zoneMarkingState.macd.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            if (allConditionsMet && !inZone) {
                                inZone = true;
                                zoneStart = resampledData[i].date;
                                zoneStartIndex = i;
                            } else if (!allConditionsMet && inZone) {
                                const zoneEndIndex = i - 1;

                                // åˆ¤æ–·æ˜¯å–®æ ¹Kæ£’é‚„æ˜¯å€åŸŸ
                                if (zoneStartIndex === zoneEndIndex) {
                                    // å–®æ ¹Kæ£’ï¼šä½¿ç”¨å‚ç›´ç·š
                                    compositeMarkLines.push({
                                        xAxis: zoneStart,
                                        lineStyle: { color: 'rgba(255, 107, 107, 0.15)', width: 3, type: 'solid' }
                                    });
                                } else {
                                    // å¤šæ ¹Kæ£’ï¼šä½¿ç”¨å€åŸŸ
                                    compositeMarkAreas.push([
                                        { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 107, 107, 0.15)' } },
                                        { xAxis: resampledData[zoneEndIndex].date }
                                    ]);
                                }

                                // è¨˜éŒ„ä½æª”å€çµæŸå¾Œçš„ä¸‹ä¸€æ ¹Kæ£’æ”¶ç›¤åƒ¹
                                const nextIndex = i;
                                if (nextIndex < resampledData.length) {
                                    const nextCandle = resampledData[nextIndex];

                                    // ğŸ” é™¤éŒ¯ï¼šæª¢æŸ¥ä½æª”å€æœ€å¾Œä¸€æ ¹Kæ£’çš„æŒ‡æ¨™å€¼
                                    const kValue = kdResult.k[zoneEndIndex];
                                    const dValue = kdResult.d[zoneEndIndex];
                                    const rsiValue = rsi5[zoneEndIndex];
                                    const macdValue = macdResult.dif[zoneEndIndex];

                                    const kdOK = (!zoneMarkingState.composite.useKD) ||
                                        (kValue !== null && kValue < zoneMarkingState.kd.threshold);
                                    const rsiOK = (!zoneMarkingState.composite.useRSI) ||
                                        (rsiValue !== null && rsiValue < zoneMarkingState.rsi.threshold);
                                    const macdOK = (!zoneMarkingState.composite.useMACD) ||
                                        (macdValue !== null && macdValue < zoneMarkingState.macd.threshold);

                                    console.log(`ğŸ¯ #${postZoneMarkers.data.length + 1} [${resampledData[zoneEndIndex].date}]:`, {
                                        'K': kValue?.toFixed(1), 'D': dValue?.toFixed(1), 'KDâœ“': kdOK,
                                        'RSI': rsiValue?.toFixed(1), 'RSIâœ“': rsiOK,
                                        'MACD': macdValue?.toFixed(1), 'MACDâœ“': macdOK,
                                        'å…¨ç¬¦åˆ': kdOK && rsiOK && macdOK
                                    });

                                    postZoneMarkers.data.push([
                                        nextIndex,  // x: ç´¢å¼•ä½ç½®
                                        nextCandle.close,  // y: æ”¶ç›¤åƒ¹
                                        nextCandle.date,  // é¡å¤–è³‡æ–™ï¼šæ—¥æœŸ
                                        nextCandle.close  // é¡å¤–è³‡æ–™ï¼šæ”¶ç›¤åƒ¹ï¼ˆç”¨æ–¼æ¨™ç±¤ï¼‰
                                    ]);
                                }
                                inZone = false;
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                compositeMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 107, 107, 0.15)', width: 3, type: 'solid' }
                                });
                            } else {
                                compositeMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 107, 107, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    } // çµæŸ hasAnyIndicator æª¢æŸ¥
                } // çµæŸä½æª”å€åŸŸæ¨™è¨˜çš„ else å€å¡Š

                // === é«˜æª”å€åŸŸæ¨™è¨˜ ===
                const highKdMarkAreas = [];
                const highKdMarkLines = [];
                const highRsiMarkAreas = [];
                const highRsiMarkLines = [];
                const highMacdMarkAreas = [];
                const highMacdMarkLines = [];
                const highCompositeMarkAreas = [];
                const highCompositeMarkLines = [];

                if (!zoneMarkingState.highMasterEnabled) {
                    // é«˜æª”æ¨™è¨˜é—œé–‰æ™‚ï¼Œè¿”å›ç©ºæ¨™è¨˜
                } else {
                    const hasAnyHighIndicator = zoneMarkingState.highComposite.useKD ||
                        zoneMarkingState.highComposite.useRSI ||
                        zoneMarkingState.highComposite.useMACD;

                    // KD é«˜æª”å€åŸŸæ¨™è¨˜ï¼ˆKå€¼é«˜æ–¼é–¾å€¼æ‰æ¨™è¨˜ï¼‰
                    if (indicatorVisible.kd && zoneMarkingState.highComposite.useKD) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < kdResult.k.length; i++) {
                            const kValue = kdResult.k[i];
                            const dValue = kdResult.d[i];

                            if (kValue !== null && dValue !== null) {
                                const isHigh = kValue > zoneMarkingState.highKd.threshold;

                                if (isHigh && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isHigh && inZone) {
                                    const zoneEndIndex = i - 1;
                                    if (zoneStartIndex === zoneEndIndex) {
                                        highKdMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(255, 140, 0, 0.25)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        highKdMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 140, 0, 0.25)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                highKdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 140, 0, 0.25)', width: 2, type: 'solid' }
                                });
                            } else {
                                highKdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 140, 0, 0.25)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // RSI é«˜æª”å€åŸŸæ¨™è¨˜
                    if (indicatorVisible.rsi && zoneMarkingState.highComposite.useRSI) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < rsi5.length; i++) {
                            const rsiValue = rsi5[i];

                            if (rsiValue !== null) {
                                const isHigh = rsiValue > zoneMarkingState.highRsi.threshold;

                                if (isHigh && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isHigh && inZone) {
                                    const zoneEndIndex = i - 1;
                                    if (zoneStartIndex === zoneEndIndex) {
                                        highRsiMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(255, 99, 71, 0.15)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        highRsiMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 99, 71, 0.15)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                highRsiMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 99, 71, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                highRsiMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 99, 71, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // MACD é«˜æª”å€åŸŸæ¨™è¨˜
                    if (indicatorVisible.macd && zoneMarkingState.highComposite.useMACD) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < macdResult.dif.length; i++) {
                            const difValue = macdResult.dif[i];

                            if (difValue !== null) {
                                const isHigh = difValue > zoneMarkingState.highMacd.threshold;

                                if (isHigh && !inZone) {
                                    inZone = true;
                                    zoneStart = resampledData[i].date;
                                    zoneStartIndex = i;
                                } else if (!isHigh && inZone) {
                                    const zoneEndIndex = i - 1;
                                    if (zoneStartIndex === zoneEndIndex) {
                                        highMacdMarkLines.push({
                                            xAxis: zoneStart,
                                            lineStyle: { color: 'rgba(255, 69, 0, 0.15)', width: 2, type: 'solid' }
                                        });
                                    } else {
                                        highMacdMarkAreas.push([
                                            { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 69, 0, 0.15)' } },
                                            { xAxis: resampledData[zoneEndIndex].date }
                                        ]);
                                    }
                                    inZone = false;
                                }
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                highMacdMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(255, 69, 0, 0.15)', width: 2, type: 'solid' }
                                });
                            } else {
                                highMacdMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(255, 69, 0, 0.15)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }

                    // Kç·šå€é«˜æª”è¤‡åˆæ¨™è¨˜
                    if (hasAnyHighIndicator) {
                        let inZone = false;
                        let zoneStart = null;
                        let zoneStartIndex = null;

                        for (let i = 0; i < resampledData.length; i++) {
                            let allConditionsMet = true;

                            if (zoneMarkingState.highComposite.useKD) {
                                const kValue = kdResult.k[i];
                                const dValue = kdResult.d[i];
                                if (kValue === null || kValue <= zoneMarkingState.highKd.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            if (zoneMarkingState.highComposite.useRSI) {
                                const rsiValue = rsi5[i];
                                if (rsiValue === null || rsiValue <= zoneMarkingState.highRsi.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            if (zoneMarkingState.highComposite.useMACD) {
                                const difValue = macdResult.dif[i];
                                if (difValue === null || difValue <= zoneMarkingState.highMacd.threshold) {
                                    allConditionsMet = false;
                                }
                            }

                            if (allConditionsMet && !inZone) {
                                inZone = true;
                                zoneStart = resampledData[i].date;
                                zoneStartIndex = i;
                            } else if (!allConditionsMet && inZone) {
                                const zoneEndIndex = i - 1;

                                if (zoneStartIndex === zoneEndIndex) {
                                    highCompositeMarkLines.push({
                                        xAxis: zoneStart,
                                        lineStyle: { color: 'rgba(220, 20, 60, 0.2)', width: 3, type: 'solid' }
                                    });
                                } else {
                                    highCompositeMarkAreas.push([
                                        { xAxis: zoneStart, itemStyle: { color: 'rgba(220, 20, 60, 0.2)' } },
                                        { xAxis: resampledData[zoneEndIndex].date }
                                    ]);
                                }

                                // è¨˜éŒ„é«˜æª”å€çµæŸå¾Œçš„ä¸‹ä¸€æ ¹Kæ£’æ”¶ç›¤åƒ¹
                                const nextIndex = i;
                                if (nextIndex < resampledData.length) {
                                    const nextCandle = resampledData[nextIndex];

                                    // æª¢æŸ¥é«˜æª”å€æœ€å¾Œä¸€æ ¹Kæ£’çš„æŒ‡æ¨™å€¼
                                    const kValue = kdResult.k[zoneEndIndex];
                                    const dValue = kdResult.d[zoneEndIndex];
                                    const rsiValue = rsi5[zoneEndIndex];
                                    const macdValue = macdResult.dif[zoneEndIndex];

                                    const kdOK = (!zoneMarkingState.highComposite.useKD) ||
                                        (kValue !== null && kValue > zoneMarkingState.highKd.threshold);
                                    const rsiOK = (!zoneMarkingState.highComposite.useRSI) ||
                                        (rsiValue !== null && rsiValue > zoneMarkingState.highRsi.threshold);
                                    const macdOK = (!zoneMarkingState.highComposite.useMACD) ||
                                        (macdValue !== null && macdValue > zoneMarkingState.highMacd.threshold);

                                    console.log(`ğŸŸ£ é«˜æª”å€ #${highPostZoneMarkers.data.length + 1} [${resampledData[zoneEndIndex].date}]:`, {
                                        'K': kValue?.toFixed(1), 'D': dValue?.toFixed(1), 'KDâœ“': kdOK,
                                        'RSI': rsiValue?.toFixed(1), 'RSIâœ“': rsiOK,
                                        'MACD': macdValue?.toFixed(1), 'MACDâœ“': macdOK,
                                        'å…¨ç¬¦åˆ': kdOK && rsiOK && macdOK
                                    });

                                    highPostZoneMarkers.data.push([
                                        nextIndex,  // x: ç´¢å¼•ä½ç½®
                                        nextCandle.close,  // y: æ”¶ç›¤åƒ¹
                                        nextCandle.date,  // é¡å¤–è³‡æ–™ï¼šæ—¥æœŸ
                                        nextCandle.close  // é¡å¤–è³‡æ–™ï¼šæ”¶ç›¤åƒ¹ï¼ˆç”¨æ–¼æ¨™ç±¤ï¼‰
                                    ]);
                                }
                                inZone = false;
                            }
                        }

                        if (inZone) {
                            const zoneEndIndex = resampledData.length - 1;
                            if (zoneStartIndex === zoneEndIndex) {
                                highCompositeMarkLines.push({
                                    xAxis: zoneStart,
                                    lineStyle: { color: 'rgba(220, 20, 60, 0.2)', width: 3, type: 'solid' }
                                });
                            } else {
                                highCompositeMarkAreas.push([
                                    { xAxis: zoneStart, itemStyle: { color: 'rgba(220, 20, 60, 0.2)' } },
                                    { xAxis: resampledData[zoneEndIndex].date }
                                ]);
                            }
                        }
                    }
                }

                // === MACD D-M è²·è³£é»æª¢æ¸¬ï¼ˆåŸºæ–¼é–¥å€¼ï¼‰===
                const buySellMarkers = { buy: [], sell: [] };
                const dmValues = macdResult.dm;

                let lastTrend = null; // 'decreasing' æˆ– 'increasing' æˆ– null

                for (let i = 1; i < dmValues.length; i++) {
                    const prevDM = dmValues[i - 1];
                    const currDM = dmValues[i];

                    // ç¢ºä¿å€¼å­˜åœ¨
                    if (prevDM !== null && currDM !== null) {
                        let currentTrend = null;

                        // åˆ¤æ–·ç•¶å‰è¶¨å‹¢
                        if (currDM > prevDM) {
                            currentTrend = 'increasing'; // å‘ä¸Šï¼ˆè² å‘æ¸›å°‘æˆ–æ­£å‘å¢åŠ ï¼‰
                        } else if (currDM < prevDM) {
                            currentTrend = 'decreasing'; // å‘ä¸‹ï¼ˆè² å‘å¢åŠ æˆ–æ­£å‘æ¸›å°‘ï¼‰
                        }

                        // æª¢æ¸¬è¶¨å‹¢åè½‰
                        if (lastTrend !== null && currentTrend !== null && lastTrend !== currentTrend) {
                            // è¶¨å‹¢æ”¹è®Šäº†
                            if (currentTrend === 'increasing' && prevDM < 0) {
                                // å¾å‘ä¸‹è½‰ç‚ºå‘ä¸Šï¼Œä¸”åœ¨è² å€¼å€åŸŸ
                                // æª¢æŸ¥æ˜¯å¦ç¬¦åˆè²·é»æ¢ä»¶
                                // D-Mè² å€¼åè½‰å¾Œä½æ–¼è²·é»é–¾å€¼ -> è²·é»ï¼ˆå¢¨ç¶ è‰²ï¼‰
                                if (currDM < zoneMarkingState.macdBuySell.buyThreshold) {
                                    buySellMarkers.buy.push([
                                        i,
                                        resampledData[i].close,
                                        resampledData[i].date,
                                        resampledData[i].close,
                                        currDM.toFixed(2)
                                    ]);
                                }
                            } else if (currentTrend === 'decreasing' && prevDM > 0) {
                                // å¾å‘ä¸Šè½‰ç‚ºå‘ä¸‹ï¼Œä¸”åœ¨æ­£å€¼å€åŸŸ
                                // æª¢æŸ¥æ˜¯å¦ç¬¦åˆè³£é»æ¢ä»¶
                                // D-Mæ­£å€¼åè½‰å¾Œé«˜æ–¼è³£é»é–¾å€¼ -> è³£é»ï¼ˆæ·±ç´…è‰²ï¼‰
                                if (currDM > zoneMarkingState.macdBuySell.sellThreshold) {
                                    buySellMarkers.sell.push([
                                        i,
                                        resampledData[i].close,
                                        resampledData[i].date,
                                        resampledData[i].close,
                                        currDM.toFixed(2)
                                    ]);
                                }
                            }
                        }

                        // æ›´æ–°è¶¨å‹¢ç‹€æ…‹
                        if (currentTrend !== null) {
                            lastTrend = currentTrend;
                        }
                    }
                }

                // é™¤éŒ¯æ—¥èªŒ
                console.log('ğŸ“Š å€åŸŸæ¨™è¨˜çµ±è¨ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
                console.log(`  ğŸ”´ è¤‡åˆä½æª”å€: ${compositeMarkAreas.length} å€‹`);
                console.log(`  ğŸŸ¡ KD ä½æª”å€: ${kdMarkAreas.length} å€‹`);
                console.log(`  ğŸŸ£ RSI ä½æª”å€: ${rsiMarkAreas.length} å€‹`);
                console.log(`  ğŸ”µ MACD ä½æª”å€: ${macdMarkAreas.length} å€‹`);
                console.log(`  ğŸ¯ åå½ˆæ¨™è¨˜é»: ${postZoneMarkers.data.length} å€‹`);
                console.log(`  ğŸ”º è¤‡åˆé«˜æª”å€: ${highCompositeMarkAreas.length} å€‹`);
                console.log(`  ğŸŸ  KD é«˜æª”å€: ${highKdMarkAreas.length} å€‹`);
                console.log(`  ğŸ”´ RSI é«˜æª”å€: ${highRsiMarkAreas.length} å€‹`);
                console.log(`  ğŸŸ¥ MACD é«˜æª”å€: ${highMacdMarkAreas.length} å€‹`);
                console.log(`  ğŸŸ£ é«˜æª”å¾Œæ¨™è¨˜é»: ${highPostZoneMarkers.data.length} å€‹`);
                console.log(`  ğŸ”´ è²·é»æ¨™è¨˜: ${buySellMarkers.buy.length} å€‹`);
                console.log(`  ğŸŸ¢ è³£é»æ¨™è¨˜: ${buySellMarkers.sell.length} å€‹`);
                console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

                return {
                    kd: { data: kdMarkAreas, lines: kdMarkLines },
                    rsi: { data: rsiMarkAreas, lines: rsiMarkLines },
                    macd: { data: macdMarkAreas, lines: macdMarkLines },
                    composite: { data: compositeMarkAreas, lines: compositeMarkLines },
                    postZoneMarkers,
                    highPostZoneMarkers,  // é«˜æª”å€å¾Œçš„æ¨™è¨˜é»
                    buySellMarkers,       // è²·è³£é»æ¨™è¨˜
                    // é«˜æª”å€åŸŸæ¨™è¨˜
                    highKd: { data: highKdMarkAreas, lines: highKdMarkLines },
                    highRsi: { data: highRsiMarkAreas, lines: highRsiMarkLines },
                    highMacd: { data: highMacdMarkAreas, lines: highMacdMarkLines },
                    highComposite: { data: highCompositeMarkAreas, lines: highCompositeMarkLines }
                };
            }

            function updateChart(periodType) {
                console.time(`UpdateChart-${periodType}`);
                lastClickedIndex = null; // é‡ç½®é»æ“Šç‹€æ…‹
                multiCrosshairPoints = []; // æ¸…ç©ºå¤šé»æ¨™è¨˜
                currentPeriod = periodType;

                controlButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.period === periodType);
                });

                statusEl.innerHTML = `ç³»çµ±ç‹€æ…‹ï¼šæ­£åœ¨å°‡ ${dailyData.length.toLocaleString()} ç­†æ—¥Kè½‰æ›ç‚º ${periodType} è³‡æ–™...`;
                console.time(`Resample-${periodType}`);
                const resampledData = DataService.resampleToPeriod(dailyData, periodType);
                console.timeEnd(`Resample-${periodType}`);

                const closePrices = resampledData.map(item => item.close);
                const macdResult = TechUtils.calculateMACD(closePrices);
                const kdResult = TechUtils.calculateKD(resampledData);
                const rsi5 = TechUtils.calculateRSI(closePrices, 5);  // å¿«ç·š (ä¸€é€±)
                const rsi10 = TechUtils.calculateRSI(closePrices, 10); // æ…¢ç·š (å…©é€±)

                // å‹•æ…‹è¨ˆç®— MAï¼ˆæ ¹æ“š maConfigï¼‰
                const maData = maConfig.map(config =>
                    TechUtils.calculateSMA(closePrices, config.period)
                );

                const periodMap = { 'daily': 'æ—¥ç·š', 'weekly': 'å‘¨ç·š', 'bi-weekly': 'é›™å‘¨ç·š', 'tri-weekly': 'ä¸‰å‘¨ç·š', 'monthly': 'æœˆç·š' };
                const periodName = periodMap[periodType];

                // å„²å­˜ç•¶å‰åœ–è¡¨æ•¸æ“šä¾›æ¨™è¨˜æ›´æ–°ä½¿ç”¨
                currentChartData = {
                    resampledData,
                    kdResult,
                    rsi5,
                    rsi10,
                    maData,
                    maConfig,
                    macdResult,
                    periodName: periodName
                };

                // ç”Ÿæˆæ¨™è¨˜å€åŸŸ
                const markAreas = generateMarkAreas(currentChartData);
                console.log('âœ… markAreas.postZoneMarkers:', markAreas.postZoneMarkers);
                console.log('âœ… markAreas.highPostZoneMarkers:', markAreas.highPostZoneMarkers);

                chartTitleEl.innerHTML = `ğŸ“ˆ å°ç£åŠ æ¬ŠæŒ‡æ•¸æ­·å²å›æ¸¬ (Beta ç‰ˆ) <span class="badge">Real Data</span>`;

                statusEl.innerHTML = `
                çµ±è¨ˆç¯„åœï¼š<b>${dailyData[0].date}</b> è‡³ <b>${dailyData[dailyData.length - 1].date}</b><br>
                åŸå§‹æ—¥Kï¼š${dailyData.length.toLocaleString()} ç­† |
                èšåˆ${periodName}ï¼š${resampledData.length.toLocaleString()} ç­†
            `;

                // å‹•æ…‹è¨ˆç®—ç¶²æ ¼å¸ƒå±€
                const visibleIndicators = [];
                if (indicatorVisible.macd) visibleIndicators.push('macd');
                if (indicatorVisible.kd) visibleIndicators.push('kd');
                if (indicatorVisible.rsi) visibleIndicators.push('rsi');

                const indicatorCount = visibleIndicators.length;

                // --- éŸ¿æ‡‰å¼è¨­å®š ---
                const screenWidth = window.innerWidth;
                const isMobilePortrait = screenWidth <= 768;
                const isTabletOrLandscape = screenWidth > 768 && screenWidth <= 1024;
                const gridLeft = isMobilePortrait ? '12%' : '80px';

                // æ‰‹æ©Ÿç›´å¼æ™‚ç¸®å°æŒ‡æ¨™åœ–é«˜åº¦ï¼Œç¢ºä¿ K ç·šåœ–ç¶­æŒè¼ƒå¤§çš„ç›¸å°é«˜åº¦
                const indicatorHeight = isMobilePortrait ? 9 : 11.5; // æ¯å€‹æŒ‡æ¨™é«˜åº¦ç™¾åˆ†æ¯”
                // æ ¹æ“šé€±æœŸèª¿æ•´æŠ€è¡“ç·šåœ–é–“è·ï¼Œæ‰‹æ©Ÿç›´å¼æ™‚é¡å¤–æ¸›å°‘ä»¥é¨°å‡ºç©ºé–“çµ¦ K ç·šåœ–
                // const basePeriodSpacing = (periodType === 'daily') ? 6 : 8;
                const baseSpacingBetweenCharts = 7;
                const spacingBetweenCharts = (periodType === 'daily') ? baseSpacingBetweenCharts : 9;
                const totalIndicatorSpacing = indicatorCount > 0 ? indicatorCount * baseSpacingBetweenCharts : 0;

                const dataZoomSectionHeight = 3 + baseSpacingBetweenCharts; // dataZoom å…ƒä»¶é«˜åº¦(3) + å…¶é ‚éƒ¨é–“è·

                // æ ¹æ“šè¢å¹•æ¨¡å¼è¨ˆç®—æ¨™é¡Œéœ€è¦çš„é¡å¤–ç©ºé–“
                // æ‰‹æ©Ÿç›´å¼ï¼šKç·šæ¨™é¡Œæœ¬èº« 2 è¡Œ + MA è¡Œæ•¸ï¼ˆæ¯ 3 å€‹ MA æ›ä¸€è¡Œï¼‰
                // æ‰‹æ©Ÿæ©«å¼/å¹³æ¿ï¼šKç·šæ¨™é¡Œæœ¬èº« 1 è¡Œ + MA 1 è¡Œ
                // æ¡Œé¢ï¼šåªæœ‰ 1 è¡Œ
                const enabledMaCount = maConfig.filter(m => m.enabled).length;
                const mobileExtraLines = Math.ceil(enabledMaCount / 3); // MA éœ€è¦çš„é¡å¤–è¡Œæ•¸
                // æ‰‹æ©Ÿç›´å¼åŸºç¤ top éœ€è¦æ›´é«˜ä»¥é¿é–‹ä¸Šæ–¹çš„æŠ€è¡“æŒ‡æ¨™é–‹é—œ
                const baseMobileTop = isMobilePortrait ? 20 : 12;
                let titleExtraTop = 0;
                if (isMobilePortrait) {
                    // æ‰‹æ©Ÿç›´å¼ï¼š2 è¡Œ K ç·šè³‡è¨Š + MA è¡Œæ•¸ï¼Œæ¯è¡Œç´„ 2.5%
                    titleExtraTop = (1 + mobileExtraLines) * 2.5;
                } else if (isTabletOrLandscape) {
                    // æ‰‹æ©Ÿæ©«å¼/å¹³æ¿ï¼š1 è¡Œ MA å€¼
                    titleExtraTop = 2.5;
                }

                const baseKLineTop = baseMobileTop + titleExtraTop; // åŸºæº– top åŠ ä¸Šæ¨™é¡Œé¡å¤–ç©ºé–“
                const kLineHeight = 100 - baseKLineTop - (indicatorCount * indicatorHeight) - totalIndicatorSpacing - dataZoomSectionHeight;

                // å»ºç«‹ç¶²æ ¼é…ç½®
                const grids = [{ left: gridLeft, right: '5%', top: `${baseKLineTop}%`, height: `${kLineHeight}%` }];

                const titles = generateTitles(resampledData.length - 1, kLineHeight);

                let currentTop = baseKLineTop + kLineHeight + spacingBetweenCharts; // ç•¶å‰ä½ç½®
                let gridIndex = 1;
                const xAxisConfigs = [{ type: 'category', data: resampledData.map(d => d.date), axisLabel: { show: false } }];
                const yAxisConfigs = [{
                    scale: true,
                    splitLine: { show: true, lineStyle: { color: '#eee' } },
                    axisLabel: {
                        formatter: function (value) {
                            return value.toLocaleString();
                        }
                    }
                }];
                const xAxisIndices = [0];

                visibleIndicators.forEach((indicator, idx) => {
                    grids.push({ left: gridLeft, right: '5%', top: `${currentTop}%`, height: `${indicatorHeight}%` });

                    xAxisConfigs.push({ type: 'category', gridIndex: gridIndex, data: resampledData.map(d => d.date), axisLabel: { show: false } });
                    xAxisIndices.push(gridIndex);

                    if (indicator === 'macd') {
                        yAxisConfigs.push({ scale: true, gridIndex: gridIndex, splitLine: { show: false } });
                    } else {
                        yAxisConfigs.push({ scale: true, gridIndex: gridIndex, min: 0, max: 100, splitLine: { show: true, lineStyle: { color: '#eee' } } });
                    }

                    currentTop += indicatorHeight + spacingBetweenCharts;
                    gridIndex++;
                });

                // å»ºç«‹ç³»åˆ—æ•¸æ“š
                const series = [
                    {
                        name: periodName, type: 'candlestick', data: resampledData.map(d => d.values),
                        itemStyle: { color: '#eb5454', color0: '#47b262', borderColor: '#eb5454', borderColor0: '#47b262' },
                        large: true,
                        markArea: {
                            data: [...markAreas.composite.data, ...markAreas.highComposite.data]
                        },
                        markLine: {
                            data: [...markAreas.composite.lines, ...markAreas.highComposite.lines],
                            symbol: 'none',
                            label: { show: false }
                        },
                        z: 5
                    },
                    {
                        name: 'ä½æª”åå½ˆæ”¶ç›¤',
                        type: 'scatter',
                        data: markAreas.postZoneMarkers.data,
                        symbolSize: 16,
                        itemStyle: {
                            color: '#ff6600',
                            borderColor: '#fff',
                            borderWidth: 2.5,
                            shadowBlur: 4,
                            shadowColor: 'rgba(255, 102, 0, 0.5)'
                        },
                        emphasis: {
                            scale: false,
                            itemStyle: {
                                color: '#ff4400',
                                shadowBlur: 8,
                                shadowColor: 'rgba(255, 68, 0, 0.8)'
                            }
                        },
                        label: {
                            show: true,
                            position: 'top',
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                return closePrice.toLocaleString();
                            },
                            fontSize: 11,
                            fontWeight: 'bold',
                            color: '#ff6600',
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            padding: [3, 6],
                            borderRadius: 3,
                            borderColor: '#ff6600',
                            borderWidth: 1
                        },
                        tooltip: {
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                const date = params.value[2];
                                return `<strong>ä½æª”åå½ˆæ”¶ç›¤</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}`;
                            }
                        },
                        z: 10
                    },
                    {
                        name: 'é«˜æª”å›è½æ”¶ç›¤',
                        type: 'scatter',
                        data: markAreas.highPostZoneMarkers.data,
                        symbolSize: 16,
                        itemStyle: {
                            color: '#9b59b6',
                            borderColor: '#fff',
                            borderWidth: 2.5,
                            shadowBlur: 4,
                            shadowColor: 'rgba(155, 89, 182, 0.5)'
                        },
                        emphasis: {
                            scale: false,
                            itemStyle: {
                                color: '#8e44ad',
                                shadowBlur: 8,
                                shadowColor: 'rgba(142, 68, 173, 0.8)'
                            }
                        },
                        label: {
                            show: true,
                            position: 'bottom',
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                return closePrice.toLocaleString();
                            },
                            fontSize: 11,
                            fontWeight: 'bold',
                            color: '#9b59b6',
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            padding: [3, 6],
                            borderRadius: 3,
                            borderColor: '#9b59b6',
                            borderWidth: 1
                        },
                        tooltip: {
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                const date = params.value[2];
                                return `<strong>é«˜æª”å›è½æ”¶ç›¤</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}`;
                            }
                        },
                        z: 10
                    },
                    {
                        name: 'è²·é»',
                        type: 'scatter',
                        data: (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.buyEnabled)
                            ? markAreas.buySellMarkers.buy : [],
                        symbolSize: 14,
                        itemStyle: {
                            color: '#1a5f1a',  // å¢¨ç¶ è‰²
                            borderColor: '#fff',
                            borderWidth: 2.5,
                            shadowBlur: 4,
                            shadowColor: 'rgba(26, 95, 26, 0.6)'
                        },
                        emphasis: {
                            scale: false,
                            itemStyle: {
                                color: '#0f4f0f',
                                shadowBlur: 8,
                                shadowColor: 'rgba(26, 95, 26, 0.9)'
                            }
                        },
                        label: {
                            show: true,
                            position: 'top',
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                return `${closePrice.toLocaleString()}`;
                            },
                            fontSize: 10,
                            fontWeight: 'bold',
                            color: '#1a5f1a',
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            padding: [3, 6],
                            borderRadius: 3,
                            borderColor: '#1a5f1a',
                            borderWidth: 1.5
                        },
                        tooltip: {
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                const date = params.value[2];
                                const dmValue = params.value[4];
                                return `<strong style="color: #1a5f1a;">ä½é»</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}<br/>D-M: ${dmValue}`;
                            }
                        },
                        z: 12
                    },
                    {
                        name: 'è³£é»',
                        type: 'scatter',
                        data: (zoneMarkingState.macdBuySell.masterEnabled && zoneMarkingState.macdBuySell.sellEnabled)
                            ? markAreas.buySellMarkers.sell : [],
                        symbolSize: 14,
                        itemStyle: {
                            color: '#8b0000',  // æ·±ç´…è‰²
                            borderColor: '#fff',
                            borderWidth: 2.5,
                            shadowBlur: 4,
                            shadowColor: 'rgba(139, 0, 0, 0.6)'
                        },
                        emphasis: {
                            scale: false,
                            itemStyle: {
                                color: '#a00000',
                                shadowBlur: 8,
                                shadowColor: 'rgba(139, 0, 0, 0.9)'
                            }
                        },
                        label: {
                            show: true,
                            position: 'bottom',
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                return `${closePrice.toLocaleString()}`;
                            },
                            fontSize: 10,
                            fontWeight: 'bold',
                            color: '#8b0000',
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            padding: [3, 6],
                            borderRadius: 3,
                            borderColor: '#8b0000',
                            borderWidth: 1.5
                        },
                        tooltip: {
                            formatter: (params) => {
                                const closePrice = params.value[1];
                                const date = params.value[2];
                                const dmValue = params.value[4];
                                return `<strong style="color: #8b0000;">é«˜é»</strong><br/>æ—¥æœŸ: ${date}<br/>æ”¶ç›¤: ${closePrice.toLocaleString()}<br/>D-M: ${dmValue}`;
                            }
                        },
                        z: 12
                    }
                ];

                // å‹•æ…‹æ·»åŠ  MA ç³»åˆ—ï¼ˆæ ¹æ“š maConfigï¼‰
                maConfig.forEach((config, idx) => {
                    if (config.enabled) {
                        series.push({
                            name: `MA${config.period}`,
                            type: 'line',
                            data: maData[idx],
                            smooth: true,
                            lineStyle: { width: 1.5, color: config.color },
                            symbol: 'none'
                        });
                    }
                });

                // å‹•æ…‹ç”Ÿæˆ MA åœ–ä¾‹
                const legendData = maConfig
                    .filter(config => config.enabled)
                    .map(config => ({
                        name: `MA${config.period}`,
                        itemStyle: { color: config.color }
                    }));

                // æ ¹æ“šå¯è¦‹æ€§æ·»åŠ æŒ‡æ¨™ç³»åˆ—
                visibleIndicators.forEach((indicator, idx) => {
                    const axisIndex = idx + 1;

                    if (indicator === 'macd') {
                        legendData.push(
                            { name: 'DIF', itemStyle: { color: LINE_COLORS.DIF } },
                            { name: 'MACD', itemStyle: { color: LINE_COLORS.MACD } }
                        );
                        series.push(
                            {
                                name: 'DIF', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: macdResult.dif, lineStyle: { color: LINE_COLORS.DIF, width: 1.5 }, symbol: 'none',
                                markArea: { data: [...markAreas.macd.data, ...markAreas.highMacd.data] },
                                markLine: { data: [...markAreas.macd.lines, ...markAreas.highMacd.lines], symbol: 'none', label: { show: false } }
                            },
                            { name: 'MACD', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.macd, lineStyle: { color: LINE_COLORS.MACD, width: 1.5 }, symbol: 'none' },
                            { name: 'D-M', type: 'bar', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: macdResult.dm, itemStyle: { color: (p) => p.value > 0 ? '#eb5454' : '#47b262' } }
                        );
                    } else if (indicator === 'kd') {
                        legendData.push(
                            { name: 'K(9)', itemStyle: { color: LINE_COLORS.K } },
                            { name: 'D(9)', itemStyle: { color: LINE_COLORS.D } }
                        );
                        series.push(
                            {
                                name: 'K(9)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: kdResult.k, lineStyle: { color: LINE_COLORS.K, width: 1.5 }, symbol: 'none',
                                markArea: { data: [...markAreas.kd.data, ...markAreas.highKd.data] },
                                markLine: { data: [...markAreas.kd.lines, ...markAreas.highKd.lines], symbol: 'none', label: { show: false } }
                            },
                            { name: 'D(9)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: kdResult.d, lineStyle: { color: LINE_COLORS.D }, symbol: 'none' },
                            {
                                name: 'KDè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: new Array(resampledData.length).fill(80),
                                lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                                symbol: 'none', silent: true, animation: false
                            },
                            {
                                name: 'KDè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: new Array(resampledData.length).fill(20),
                                lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                                symbol: 'none', silent: true, animation: false
                            }
                        );
                    } else if (indicator === 'rsi') {
                        legendData.push(
                            { name: 'RSI(5T)', itemStyle: { color: LINE_COLORS.RSI5 } },
                            { name: 'RSI(10T)', itemStyle: { color: LINE_COLORS.RSI10 } }
                        );
                        series.push(
                            {
                                name: 'RSI(5T)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: rsi5, lineStyle: { color: LINE_COLORS.RSI5, width: 2 }, symbol: 'none',
                                markArea: { data: [...markAreas.rsi.data, ...markAreas.highRsi.data] },
                                markLine: { data: [...markAreas.rsi.lines, ...markAreas.highRsi.lines], symbol: 'none', label: { show: false } }
                            },
                            { name: 'RSI(10T)', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex, data: rsi10, lineStyle: { color: LINE_COLORS.RSI10, width: 2 }, symbol: 'none' },
                            {
                                name: 'RSIè¶…è²·', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: new Array(resampledData.length).fill(80),
                                lineStyle: { color: '#ff4444', width: 1, type: 'dashed' },
                                symbol: 'none', silent: true, animation: false
                            },
                            {
                                name: 'RSIè¶…è³£', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: new Array(resampledData.length).fill(20),
                                lineStyle: { color: '#44ff44', width: 1, type: 'dashed' },
                                symbol: 'none', silent: true, animation: false
                            },
                            {
                                name: 'RSIä¸­ç·š', type: 'line', xAxisIndex: axisIndex, yAxisIndex: axisIndex,
                                data: new Array(resampledData.length).fill(50),
                                lineStyle: { color: '#999', width: 1, type: 'dotted' },
                                symbol: 'none', silent: true, animation: false
                            }
                        );
                    }
                });

                // ç‚ºæ¯å€‹ç¶²æ ¼æ·»åŠ åå­—ç·šç³»åˆ—
                grids.forEach((grid, idx) => {
                    // å–®é»åå­—ç·š
                    series.push({
                        name: `crosshair-${idx}`,
                        type: 'line',
                        xAxisIndex: idx,
                        yAxisIndex: idx,
                        data: [],
                        markLine: {
                            silent: true,
                            animation: false,
                            symbol: ['none', 'none'],
                            data: []
                        }
                    });
                    // å¤šé»åå­—ç·š
                    series.push({
                        name: `multi-crosshair-${idx}`,
                        type: 'line',
                        xAxisIndex: idx,
                        yAxisIndex: idx,
                        data: [],
                        markLine: {
                            silent: true,
                            symbol: 'none',
                            animation: false,
                            lineStyle: {
                                type: 'solid',
                                width: 1,
                                color: '#333'
                            },
                            data: []
                        },
                        // åªæœ‰ä¸»åœ–(idx=0)éœ€è¦é¡¯ç¤ºæ¼²è·Œå¹…æ¨™ç±¤
                        markArea: idx === 0 ? {
                            silent: true,
                            animation: false,
                            data: []
                        } : undefined
                    });
                });

                // å¤šé»åå­—ç·šçš„æ¨™è¨˜é»ç³»åˆ—
                series.push({
                    name: 'multiCrosshairDots',
                    type: 'scatter',
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    symbolSize: 8,
                    itemStyle: {
                        color: '#000',
                        borderColor: '#fff',
                        borderWidth: 1
                    },
                    label: {
                        show: true,
                        formatter: (params) => params.value[1].toLocaleString(),
                        fontSize: 11,
                        fontWeight: 'bold',
                        color: '#000',
                        backgroundColor: 'rgba(255, 255, 255, 0.7)',
                        padding: [2, 4],
                        borderRadius: 3
                    },
                    data: [],
                    z: 15
                });

                const dataZoomTop = 100 - dataZoomSectionHeight;

                const option = {
                    title: titles,
                    tooltip: {
                        trigger: 'axis',
                        triggerOn: 'mousemove',
                        axisPointer: {
                            type: 'cross',
                            link: [{ xAxisIndex: 'all' }]
                        }
                    },
                    axisPointer: { link: { xAxisIndex: 'all' } },
                    legend: {
                        top: 30,
                        data: legendData
                    },
                    grid: grids,
                    xAxis: xAxisConfigs,
                    yAxis: yAxisConfigs,
                    dataZoom: [
                        { type: 'inside', xAxisIndex: xAxisIndices, start: 95, end: 100 },
                        { type: 'slider', xAxisIndex: xAxisIndices, top: `${dataZoomTop}%`, start: 95, end: 100 }
                    ],
                    series: series
                };

                myChart.setOption(option, true);
                console.timeEnd(`UpdateChart-${periodType}`);

                // æ·»åŠ æ»‘é¼ ç§»å‹•äº‹ä»¶ç›£è½å™¨ï¼Œå‹•æ…‹æ›´æ–°æ¨™é¡Œæ•¸å€¼ï¼ˆåªåœ¨æœªä½¿ç”¨åå­—ç·šæ™‚ï¼‰
                myChart.off('mousemove'); // ç§»é™¤èˆŠçš„ç›£è½å™¨
                myChart.getZr().off('mousemove'); // ç§»é™¤ ZRender å±¤çš„ç›£è½å™¨

                myChart.getZr().on('mousemove', function (event) {
                    if (lastClickedIndex !== null) {
                        return;
                    }

                    const pointInPixel = [event.offsetX, event.offsetY];
                    let dataIndex = null;

                    // æª¢æŸ¥æ»‘é¼ æ˜¯å¦åœ¨ä»»ä½•ä¸€å€‹gridå…§
                    const grids = myChart.getOption().grid;
                    for (let i = 0; i < grids.length; i++) {
                        if (myChart.containPixel({ gridIndex: i }, pointInPixel)) {
                            const pointInGrid = myChart.convertFromPixel({ gridIndex: i }, pointInPixel);
                            dataIndex = Math.round(pointInGrid[0]);
                            break;
                        }
                    }

                    updateTitles(dataIndex);
                });

                // æ·»åŠ æ»‘é¼ ç§»å‡ºäº‹ä»¶ï¼Œæ¢å¾©åˆ°æœ€å¾Œä¸€æ ¹Kç·šçš„æ•¸å€¼
                myChart.getZr().off('mouseout');
                myChart.getZr().on('mouseout', function () {
                    if (lastClickedIndex !== null) {
                        return;
                    }
                    updateTitles(currentChartData.resampledData.length - 1);
                });
            }

            function generateTitles(dataIndex, kLineHeight) {
                if (dataIndex === null || dataIndex < 0 || dataIndex >= currentChartData.resampledData.length) {
                    dataIndex = currentChartData.resampledData.length - 1;
                }

                const { resampledData, kdResult, rsi5, rsi10, maData, maConfig, macdResult, periodName } = currentChartData;

                const candle = resampledData[dataIndex];
                if (!candle) return [];

                // å‹•æ…‹ç”Ÿæˆ MA å€¼
                const maValues = maData.map((data, idx) => ({
                    period: maConfig[idx].period,
                    value: data[dataIndex]?.toFixed(2) || 'N/A',
                    color: maConfig[idx].color,
                    enabled: maConfig[idx].enabled
                }));

                const changePercent = ((candle.close - candle.open) / candle.open * 100).toFixed(2);
                const changeColor = changePercent >= 0 ? '#e74c3c' : '#27ae60';
                const changeSign = changePercent >= 0 ? '+' : '';

                // éŸ¿æ‡‰å¼é¡¯ç¤ºæ¨¡å¼ï¼šæ‰‹æ©Ÿç›´å¼ (<=768px)ã€å¹³æ¿/æ‰‹æ©Ÿæ©«å¼ (769-1024px)ã€æ¡Œé¢ (>1024px)
                const screenWidth = window.innerWidth;
                const isMobilePortrait = screenWidth <= 768;
                const isTabletOrLandscape = screenWidth > 768 && screenWidth <= 1024;
                const isDesktop = screenWidth > 1024;

                const titleLeft = isMobilePortrait ? '12%' : '90px';
                const kLineTitleTop = isMobilePortrait ? '15%' : '9%';
                const indicatorTitleTopOffset = isMobilePortrait ? -3.5 : -3;
                const kLineNameFontSize = isMobilePortrait ? 13 : 14;
                const kLineLabelFontSize = isMobilePortrait ? 11 : 12;
                const kLinePadding = isMobilePortrait ? [0, 5, 0, 2] : [0, 10, 0, 2];

                // å‹•æ…‹ç”Ÿæˆ MA é¡¯ç¤ºæ–‡å­—
                const enabledMaValues = maValues.filter(ma => ma.enabled);

                // æ‰‹æ©Ÿç›´å¼ï¼šå°‡ MA å€¼åˆ†æˆå¤šè¡Œï¼Œæ¯è¡Œæœ€å¤š 3 å€‹
                const maMobileLines = [];
                for (let i = 0; i < enabledMaValues.length; i += 3) {
                    const lineItems = enabledMaValues.slice(i, i + 3).map((ma, idx) => {
                        const globalIdx = i + idx;
                        return `{labelMA${globalIdx}|MA${ma.period}:}{valMA${globalIdx}|${ma.value}}`;
                    });
                    maMobileLines.push(lineItems.join(' '));
                }
                const maMobileText = maMobileLines.join('\n');

                // æ¡Œé¢/å¹³æ¿æ¨¡å¼çš„ MA æ–‡å­—ï¼ˆå…¨éƒ¨åœ¨åŒä¸€è¡Œï¼‰
                const maDesktopText = enabledMaValues.map((ma, i) =>
                    `{labelMA${i}|MA${ma.period}:} {valMA${i}|${ma.value}}`
                ).join('  ');

                // çµ±ä¸€ K ç·šæ–‡å­—å…§å®¹ - æ ¹æ“šè¢å¹•å¯¬åº¦å‹•æ…‹èª¿æ•´æ›è¡Œ
                // æ‰‹æ©Ÿç›´å¼éœ€è¦åˆ†è¡Œï¼Œå¦å‰‡å¾Œé¢çš„å…§å®¹æœƒè¢«æˆªæ–·
                let kLineText;
                if (isMobilePortrait) {
                    // æ‰‹æ©Ÿç›´å¼ï¼šåˆ†è¡Œé¡¯ç¤ºç¢ºä¿å®Œæ•´è³‡è¨Šå¯è¦‹
                    // ç¬¬ä¸€è¡Œ: Kç·š é–‹ é«˜ ä½
                    // ç¬¬äºŒè¡Œ: æ”¶ æ¼²è·Œå¹…
                    // ç¬¬ä¸‰è¡Œèµ·: MA å€¼
                    kLineText = `{name|Kç·š}  {label|é–‹:} {val|${candle.open}}  {label|é«˜:} {val|${candle.high}}  {label|ä½:} {val|${candle.low}}\n{label|æ”¶:} {val|${candle.close}}  {label|æ¼²è·Œå¹…:} {change|${changeSign}${changePercent}%}\n${maMobileText}`;
                } else if (isTabletOrLandscape) {
                    // æ‰‹æ©Ÿæ©«å¼/å¹³æ¿ï¼šKç·šè³‡è¨Šä¸€è¡Œï¼ŒMA å€¼æ›è¡Œ
                    kLineText = `{name|Kç·š}   {label|é–‹:} {val|${candle.open}}  {label|é«˜:} {val|${candle.high}}  {label|ä½:} {val|${candle.low}}  {label|æ”¶:} {val|${candle.close}}  {label|æ¼²è·Œå¹…:} {change|${changeSign}${changePercent}%}\n${maDesktopText}`;
                } else {
                    // æ¡Œé¢ï¼šå…¨éƒ¨åœ¨åŒä¸€è¡Œ
                    kLineText = `{name|Kç·š}   {label|é–‹:} {val|${candle.open}}  {label|é«˜:} {val|${candle.high}}  {label|ä½:} {val|${candle.low}}  {label|æ”¶:} {val|${candle.close}}  {label|æ¼²è·Œå¹…:} {change|${changeSign}${changePercent}%}  ${maDesktopText}`;
                }

                // å‹•æ…‹ç”Ÿæˆrichæ¨£å¼
                const richStyles = {
                    name: { fontSize: kLineNameFontSize, fontWeight: 'bold', color: '#333' },
                    label: { fontSize: kLineLabelFontSize, color: '#555' },
                    val: { fontSize: kLineLabelFontSize, fontWeight: 'bold', color: '#2c3e50', padding: kLinePadding },
                    change: { fontSize: kLineLabelFontSize, fontWeight: 'bold', color: changeColor, padding: kLinePadding }
                };
                enabledMaValues.forEach((ma, i) => {
                    richStyles[`labelMA${i}`] = { fontSize: kLineLabelFontSize, color: ma.color };
                    richStyles[`valMA${i}`] = { fontSize: kLineLabelFontSize, fontWeight: 'bold', color: ma.color, padding: kLinePadding };
                });

                const titles = [
                    { text: `å°ç£åŠ æ¬ŠæŒ‡æ•¸ (${periodName})`, left: 'center', top: 0 },
                    {
                        left: titleLeft,
                        top: kLineTitleTop,
                        text: kLineText,
                        textStyle: {
                            rich: richStyles
                        }
                    }
                ];

                // æ‰‹æ©Ÿç›´å¼æ™‚ç¸®å°æŒ‡æ¨™åœ–é«˜åº¦ï¼ˆèˆ‡ updateChart ä¿æŒä¸€è‡´ï¼‰
                const indicatorHeight = isMobilePortrait ? 9 : 11.5;
                const spacingBetweenCharts = (currentPeriod === 'daily') ? 7 : 9; // æ ¹æ“šé€±æœŸèª¿æ•´æŠ€è¡“ç·šåœ–é–“è·

                // è¨ˆç®—æ¨™é¡Œé¡å¤–ç©ºé–“ï¼ˆèˆ‡ updateChart ä¸­çš„é‚è¼¯ä¿æŒä¸€è‡´ï¼‰
                const enabledMaCount = maConfig.filter(m => m.enabled).length;
                const mobileExtraLines = Math.ceil(enabledMaCount / 3);
                let titleExtraTop = 0;
                if (isMobilePortrait) {
                    titleExtraTop = (1 + mobileExtraLines) * 2.5;
                } else if (isTabletOrLandscape) {
                    titleExtraTop = 2.5;
                }
                // æ‰‹æ©Ÿç›´å¼åŸºç¤ top éœ€è¦æ›´é«˜ä»¥é¿é–‹ä¸Šæ–¹çš„æŠ€è¡“æŒ‡æ¨™é–‹é—œï¼ˆèˆ‡ updateChart ä¿æŒä¸€è‡´ï¼‰
                const baseMobileTop = isMobilePortrait ? 20 : 12;
                const baseKLineTop = baseMobileTop + titleExtraTop;

                let currentTitleTop = baseKLineTop + parseFloat(kLineHeight) + spacingBetweenCharts;
                const visibleIndicators = [];
                if (indicatorVisible.macd) visibleIndicators.push('macd');
                if (indicatorVisible.kd) visibleIndicators.push('kd');
                if (indicatorVisible.rsi) visibleIndicators.push('rsi');

                visibleIndicators.forEach((indicator) => {
                    if (indicator === 'macd') {
                        const difValue = macdResult.dif[dataIndex]?.toFixed(2) || 'N/A';
                        const macdValue = macdResult.macd[dataIndex]?.toFixed(2) || 'N/A';
                        const dmValue = macdResult.dm[dataIndex]?.toFixed(2) || 'N/A';
                        titles.push({
                            left: titleLeft,
                            top: `${currentTitleTop + indicatorTitleTopOffset}%`,
                            text: `{name|MACD}   {labelDIF|DIF:} {valDIF|${difValue}}   {labelMACD|MACD:} {valMACD|${macdValue}}   {label|D-M:} {val|${dmValue}}`,
                            textStyle: {
                                rich: {
                                    name: { fontSize: 14, fontWeight: 'bold', color: '#333' },
                                    label: { fontSize: 12, color: '#555' },
                                    val: { fontSize: 12, fontWeight: 'bold', color: '#2c3e50', padding: [0, 10, 0, 2] },
                                    labelDIF: { fontSize: 12, color: LINE_COLORS.DIF },
                                    valDIF: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.DIF, padding: [0, 10, 0, 2] },
                                    labelMACD: { fontSize: 12, color: LINE_COLORS.MACD },
                                    valMACD: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.MACD, padding: [0, 10, 0, 2] }
                                }
                            }
                        });
                    } else if (indicator === 'kd') {
                        const kValue = kdResult.k[dataIndex]?.toFixed(2) || 'N/A';
                        const dValue = kdResult.d[dataIndex]?.toFixed(2) || 'N/A';
                        titles.push({
                            left: titleLeft,
                            top: `${currentTitleTop + indicatorTitleTopOffset}%`,
                            text: `{name|KD}   {labelK|K(9):} {valK|${kValue}}   {labelD|D(9):} {valD|${dValue}}`,
                            textStyle: {
                                rich: {
                                    name: { fontSize: 14, fontWeight: 'bold', color: '#333' },
                                    labelK: { fontSize: 12, color: LINE_COLORS.K },
                                    valK: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.K, padding: [0, 10, 0, 2] },
                                    labelD: { fontSize: 12, color: LINE_COLORS.D },
                                    valD: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.D, padding: [0, 10, 0, 2] }
                                }
                            }
                        });
                    } else if (indicator === 'rsi') {
                        const rsi5Value = rsi5[dataIndex]?.toFixed(2) || 'N/A';
                        const rsi10Value = rsi10[dataIndex]?.toFixed(2) || 'N/A';
                        titles.push({
                            left: titleLeft,
                            top: `${currentTitleTop + indicatorTitleTopOffset}%`,
                            text: `{name|RSI}   {labelRSI5|RSI(5T):} {valRSI5|${rsi5Value}}   {labelRSI10|RSI(10T):} {valRSI10|${rsi10Value}}`,
                            textStyle: {
                                rich: {
                                    name: { fontSize: 14, fontWeight: 'bold', color: '#333' },
                                    labelRSI5: { fontSize: 12, color: LINE_COLORS.RSI5 },
                                    valRSI5: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.RSI5, padding: [0, 10, 0, 2] },
                                    labelRSI10: { fontSize: 12, color: LINE_COLORS.RSI10 },
                                    valRSI10: { fontSize: 12, fontWeight: 'bold', color: LINE_COLORS.RSI10, padding: [0, 10, 0, 2] }
                                }
                            }
                        });
                    }
                    currentTitleTop += indicatorHeight + spacingBetweenCharts;
                });

                return titles;
            }

            function updateTitles(dataIndex) {
                const currentOption = myChart.getOption();
                if (!currentOption || !currentOption.grid || currentOption.grid.length === 0) return;
                const kLineHeight = parseFloat(currentOption.grid[0].height);
                const newTitles = generateTitles(dataIndex, kLineHeight);
                if (newTitles.length > 0) {
                    myChart.setOption({
                        title: newTitles
                    }, false);
                }
            }

            controlButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const period = button.dataset.period;
                    if (period && period !== currentPeriod) {
                        // é‡ç½®æ¨è–¦é…ç½®ä¸‹æ‹‰é¸å–®ç‚ºé è¨­å€¼
                        const configDropdown = document.getElementById('configDropdown');
                        configDropdown.value = '';

                        // éš±è—æ³¨æ„äº‹é …
                        const configNotes = document.getElementById('configNotes');
                        configNotes.classList.add('hidden');

                        updateChart(period);
                    }
                });
            });

            // æŒ‡æ¨™é–‹é—œæŒ‰éˆ•
            const indicatorCheckboxes = document.querySelectorAll('.indicator-checkbox input[type="checkbox"]');
            indicatorCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    const indicator = checkbox.dataset.indicator;
                    indicatorVisible[indicator] = checkbox.checked;

                    // åŒæ­¥æ›´æ–°æ§åˆ¶é¢æ¿ä¸­çš„è¤‡åˆæ¨™è¨˜é¸é …å’Œè¨­å®šå€å¡Š
                    if (indicator === 'kd') {
                        compositeKD.checked = checkbox.checked;
                        compositeKD.disabled = !checkbox.checked;
                        zoneMarkingState.composite.useKD = checkbox.checked;
                        // æ§åˆ¶ KD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                        if (checkbox.checked) {
                            kdPanelSection.classList.remove('hidden');
                        } else {
                            kdPanelSection.classList.add('hidden');
                        }
                    } else if (indicator === 'rsi') {
                        compositeRSI.checked = checkbox.checked;
                        compositeRSI.disabled = !checkbox.checked;
                        zoneMarkingState.composite.useRSI = checkbox.checked;
                        // æ§åˆ¶ RSI è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                        if (checkbox.checked) {
                            rsiPanelSection.classList.remove('hidden');
                        } else {
                            rsiPanelSection.classList.add('hidden');
                        }
                    } else if (indicator === 'macd') {
                        compositeMACD.checked = checkbox.checked;
                        compositeMACD.disabled = !checkbox.checked;
                        zoneMarkingState.composite.useMACD = checkbox.checked;
                        // æ§åˆ¶ MACD è¨­å®šå€å¡Šçš„é¡¯ç¤º/éš±è—
                        if (checkbox.checked) {
                            macdPanelSection.classList.remove('hidden');
                        } else {
                            macdPanelSection.classList.add('hidden');
                        }
                    }

                    toggleIndicatorVisibility();
                });
            });

            // é…ç½®é è¨­ç®¡ç†
            const configPresets = {
                easyMonthly: {
                    name: 'è¼•é¬†æœˆæ”¾',
                    period: 'monthly',
                    notes: [
                        'åŸå‰‡ä¸Šåœ¨ç¶ è‰²é»å‡ºç¾æ™‚è²·é€²ã€ç´«è‰²é»å‡ºç¾æ™‚è³£å‡º',
                        'è‹¥ç¶ è‰²é»è·Œç ´ç›¤æ•´ä¹Ÿè¦è‡ªè¡Œè³£å‡º',
                        'è‹¥æƒ³æœ€å¤§åŒ–æ”¶ç›Šï¼Œå¯å¾è‡ªè¡Œé æ¸¬ç¶ é»çš„å‡ºç¾ä¾†ææ—©è²·åœ¨è°·åº•'
                    ],
                    macdBuySell: {
                        masterEnabled: true,
                        sellEnabled: false,
                        buyEnabled: true,
                        sellThreshold: 0,
                        buyThreshold: 0
                    },
                    masterEnabled: false,
                    composite: {
                        useMACD: false,
                        useKD: false,
                        useRSI: false
                    },
                    highMasterEnabled: true,
                    highMacd: {
                        enabled: true,
                        threshold: 400
                    },
                    highKd: {
                        enabled: true,
                        threshold: 76
                    },
                    highComposite: {
                        useMACD: true,
                        useKD: true,
                        useRSI: false
                    }
                }
            };

            // æ‡‰ç”¨é…ç½®
            function applyConfiguration(configKey) {
                if (!configKey || !configPresets[configKey]) return;

                const config = configPresets[configKey];

                // è¨˜éŒ„æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“åœ–è¡¨
                const needFullUpdate = config.period && config.period !== currentPeriod;

                // ========== å…ˆæ›´æ–°æ‰€æœ‰ç‹€æ…‹ï¼Œå†æ¸²æŸ“åœ–è¡¨ ==========

                // 1. è¨­å®šMACDè²·è³£é»æ¨™è¨˜ï¼ˆé«˜é»é–¥å€¼å’Œä½é»é–¥å€¼ï¼‰
                if (config.macdBuySell) {
                    const macdBuySellMasterToggle = document.getElementById('macdBuySellMasterToggle');
                    const macdSellToggle = document.getElementById('macdSellToggle');
                    const macdBuyToggle = document.getElementById('macdBuyToggle');
                    const macdSellThreshold = document.getElementById('macdSellThreshold');
                    const macdSellThresholdRange = document.getElementById('macdSellThresholdRange');
                    const macdBuyThreshold = document.getElementById('macdBuyThreshold');
                    const macdBuyThresholdRange = document.getElementById('macdBuyThresholdRange');

                    // è¨­å®šç¸½é–‹é—œ
                    if (config.macdBuySell.masterEnabled !== undefined) {
                        macdBuySellMasterToggle.checked = config.macdBuySell.masterEnabled;
                        zoneMarkingState.macdBuySell.masterEnabled = config.macdBuySell.masterEnabled;
                    }

                    macdSellToggle.checked = config.macdBuySell.sellEnabled;
                    zoneMarkingState.macdBuySell.sellEnabled = config.macdBuySell.sellEnabled;

                    macdBuyToggle.checked = config.macdBuySell.buyEnabled;
                    zoneMarkingState.macdBuySell.buyEnabled = config.macdBuySell.buyEnabled;

                    macdSellThreshold.value = config.macdBuySell.sellThreshold;
                    macdSellThresholdRange.value = config.macdBuySell.sellThreshold;
                    zoneMarkingState.macdBuySell.sellThreshold = config.macdBuySell.sellThreshold;

                    macdBuyThreshold.value = config.macdBuySell.buyThreshold;
                    macdBuyThresholdRange.value = config.macdBuySell.buyThreshold;
                    zoneMarkingState.macdBuySell.buyThreshold = config.macdBuySell.buyThreshold;
                }

                // 2. è¨­å®šé«˜æª”å€åŸŸæ¨™è¨˜
                const highMasterToggle = document.getElementById('highMasterToggle');
                highMasterToggle.checked = config.highMasterEnabled !== undefined ? config.highMasterEnabled : false;
                zoneMarkingState.highMasterEnabled = highMasterToggle.checked;

                if (config.highMacd) {
                    const highMacdThreshold = document.getElementById('highMacdThreshold');
                    const highMacdThresholdRange = document.getElementById('highMacdThresholdRange');
                    highMacdThreshold.value = config.highMacd.threshold;
                    highMacdThresholdRange.value = config.highMacd.threshold;
                    zoneMarkingState.highMacd.threshold = config.highMacd.threshold;
                }

                if (config.highKd) {
                    const highKdThreshold = document.getElementById('highKdThreshold');
                    const highKdThresholdRange = document.getElementById('highKdThresholdRange');
                    highKdThreshold.value = config.highKd.threshold;
                    highKdThresholdRange.value = config.highKd.threshold;
                    zoneMarkingState.highKd.threshold = config.highKd.threshold;
                }

                if (config.highRsi) {
                    const highRsiThreshold = document.getElementById('highRsiThreshold');
                    const highRsiThresholdRange = document.getElementById('highRsiThresholdRange');
                    highRsiThreshold.value = config.highRsi.threshold;
                    highRsiThresholdRange.value = config.highRsi.threshold;
                    zoneMarkingState.highRsi.threshold = config.highRsi.threshold;
                }

                if (config.highComposite) {
                    const highCompositeMACD = document.getElementById('highCompositeMACD');
                    const highCompositeKD = document.getElementById('highCompositeKD');
                    const highCompositeRSI = document.getElementById('highCompositeRSI');

                    const highMacdPanelSection = document.getElementById('highMacdSection');
                    const highKdPanelSection = document.getElementById('highKdSection');
                    const highRsiPanelSection = document.getElementById('highRsiSection');

                    highCompositeMACD.checked = config.highComposite.useMACD;
                    zoneMarkingState.highComposite.useMACD = config.highComposite.useMACD;
                    if (config.highComposite.useMACD) {
                        highMacdPanelSection.classList.remove('hidden');
                    } else {
                        highMacdPanelSection.classList.add('hidden');
                    }

                    highCompositeKD.checked = config.highComposite.useKD;
                    zoneMarkingState.highComposite.useKD = config.highComposite.useKD;
                    if (config.highComposite.useKD) {
                        highKdPanelSection.classList.remove('hidden');
                    } else {
                        highKdPanelSection.classList.add('hidden');
                    }

                    highCompositeRSI.checked = config.highComposite.useRSI;
                    zoneMarkingState.highComposite.useRSI = config.highComposite.useRSI;
                    if (config.highComposite.useRSI) {
                        highRsiPanelSection.classList.remove('hidden');
                    } else {
                        highRsiPanelSection.classList.add('hidden');
                    }
                }

                // 3. è¨­å®šä½æª”å€åŸŸæ¨™è¨˜
                const masterToggle = document.getElementById('masterToggle');
                masterToggle.checked = config.masterEnabled !== undefined ? config.masterEnabled : false;
                zoneMarkingState.masterEnabled = masterToggle.checked;

                // 4. è¨­å®šä½æª”å€åŸŸè¤‡åˆæ¢ä»¶
                if (config.composite) {
                    const compositeMACD = document.getElementById('compositeMACD');
                    const compositeKD = document.getElementById('compositeKD');
                    const compositeRSI = document.getElementById('compositeRSI');

                    const lowMacdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="macd"]');
                    const lowKdPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="kd"]');
                    const lowRsiPanelSection = lowPricePanel.querySelector('.panel-section[data-indicator="rsi"]');

                    compositeMACD.checked = config.composite.useMACD;
                    zoneMarkingState.composite.useMACD = config.composite.useMACD;
                    if (config.composite.useMACD) {
                        lowMacdPanelSection.classList.remove('hidden');
                    } else {
                        lowMacdPanelSection.classList.add('hidden');
                    }

                    compositeKD.checked = config.composite.useKD;
                    zoneMarkingState.composite.useKD = config.composite.useKD;
                    if (config.composite.useKD) {
                        lowKdPanelSection.classList.remove('hidden');
                    } else {
                        lowKdPanelSection.classList.add('hidden');
                    }

                    compositeRSI.checked = config.composite.useRSI;
                    zoneMarkingState.composite.useRSI = config.composite.useRSI;
                    if (config.composite.useRSI) {
                        lowRsiPanelSection.classList.remove('hidden');
                    } else {
                        lowRsiPanelSection.classList.add('hidden');
                    }
                }

                // ========== æ‰€æœ‰ç‹€æ…‹æ›´æ–°å®Œç•¢ï¼Œç¾åœ¨æ›´æ–°åœ–è¡¨ ==========

                // å¦‚æœé€±æœŸæ”¹è®Šï¼Œå®Œæ•´æ¸²æŸ“åœ–è¡¨
                if (needFullUpdate) {
                    updateChart(config.period);
                } else {
                    // é€±æœŸæœªæ”¹è®Šï¼Œåªæ›´æ–°æ¨™è¨˜
                    updateChartMarkingsOnly();
                }
            }

            // é…ç½®ä¸‹æ‹‰é¸å–®äº‹ä»¶ç›£è½
            const configDropdown = document.getElementById('configDropdown');
            const configNotes = document.getElementById('configNotes');
            const configNotesList = document.getElementById('configNotesList');

            configDropdown.addEventListener('change', (e) => {
                const selectedConfig = e.target.value;
                if (selectedConfig) {
                    applyConfiguration(selectedConfig);

                    // é¡¯ç¤ºæ³¨æ„äº‹é …
                    const config = configPresets[selectedConfig];
                    if (config && config.notes && config.notes.length > 0) {
                        configNotesList.innerHTML = '';
                        config.notes.forEach(note => {
                            const li = document.createElement('li');
                            li.textContent = note;
                            configNotesList.appendChild(li);
                        });
                        configNotes.classList.remove('hidden');
                    } else {
                        configNotes.classList.add('hidden');
                    }
                } else {
                    // æ¸…é™¤é¸æ“‡æ™‚éš±è—æ³¨æ„äº‹é …
                    configNotes.classList.add('hidden');
                }
            });

            updateChart(currentPeriod);

            myChart.getZr().on('click', function (event) {
                if (isMultiCrosshairMode) {
                    handleMultiCrosshairClick(event);
                } else {
                    handleSingleCrosshairClick(event);
                }
            });

            function handleSingleCrosshairClick(event) {
                const pointInPixel = [event.offsetX, event.offsetY];
                let dataIndex = null;
                let clickedGridIndex = -1;

                const grids = myChart.getOption().grid;
                for (let i = 0; i < grids.length; i++) {
                    if (myChart.containPixel({ gridIndex: i }, pointInPixel)) {
                        clickedGridIndex = i;
                        break;
                    }
                }

                if (clickedGridIndex !== -1) {
                    const pointInGrid = myChart.convertFromPixel({ gridIndex: clickedGridIndex }, pointInPixel);
                    dataIndex = pointInGrid[0];
                }

                let hLine, vLine;
                let seriesUpdate = [];

                if (dataIndex != null && currentChartData && dataIndex >= 0 && dataIndex < currentChartData.resampledData.length) {
                    if (lastClickedIndex === dataIndex) {
                        lastClickedIndex = null;
                        updateTitles(currentChartData.resampledData.length - 1);
                    } else {
                        lastClickedIndex = dataIndex;
                        updateTitles(lastClickedIndex);
                    }
                } else {
                    lastClickedIndex = null;
                    updateTitles(currentChartData.resampledData.length - 1);
                }

                if (lastClickedIndex !== null) {
                    const clickedData = currentChartData.resampledData[lastClickedIndex];
                    const closePrice = clickedData.close;
                    const date = clickedData.date;

                    hLine = {
                        yAxis: closePrice,
                        lineStyle: { color: '#2f3e4d', type: 'solid', width: 1 },
                        label: { show: true, position: 'start', formatter: closePrice.toLocaleString(), color: '#fff', backgroundColor: '#2f3e4d', padding: [4, 8], borderRadius: 4, fontSize: 12 }
                    };
                    vLine = {
                        xAxis: date,
                        lineStyle: { color: '#2f3e4d', type: 'solid', width: 1 },
                        label: { show: true, position: 'start', formatter: () => date.includes('~') ? date.replace(' ~ ', '\n') : date, color: '#fff', backgroundColor: '#2f3e4d', padding: [4, 8], borderRadius: 4, fontSize: 12 }
                    };
                }

                const gridCount = myChart.getOption().grid.length;
                for (let i = 0; i < gridCount; i++) {
                    let markLineData = [];
                    if (lastClickedIndex !== null) {
                        if (i === 0) {
                            markLineData = [hLine, vLine];
                        } else {
                            markLineData = [vLine];
                        }
                    }
                    seriesUpdate.push({ name: `crosshair-${i}`, markLine: { data: markLineData } });
                }
                myChart.setOption({ series: seriesUpdate });
            }

            function handleMultiCrosshairClick(event) {
                const pointInPixel = [event.offsetX, event.offsetY];
                let dataIndex = null;
                let clickedGridIndex = -1;

                const grids = myChart.getOption().grid;
                for (let i = 0; i < grids.length; i++) {
                    if (myChart.containPixel({ gridIndex: i }, pointInPixel)) {
                        clickedGridIndex = i;
                        break;
                    }
                }

                if (clickedGridIndex !== -1) {
                    const pointInGrid = myChart.convertFromPixel({ gridIndex: clickedGridIndex }, pointInPixel);
                    dataIndex = pointInGrid[0];
                }

                if (dataIndex != null && dataIndex >= 0 && dataIndex < currentChartData.resampledData.length) {
                    const indexInPoints = multiCrosshairPoints.indexOf(dataIndex);
                    if (indexInPoints > -1) {
                        multiCrosshairPoints.splice(indexInPoints, 1);
                    } else {
                        multiCrosshairPoints.push(dataIndex);
                    }
                    multiCrosshairPoints.sort((a, b) => a - b);
                    renderMultiCrosshairs();
                }
            }

            function renderMultiCrosshairs() {
                const markLineData = [];
                const markAreaData = [];
                const dotData = [];
                const seriesUpdate = [];

                multiCrosshairPoints.forEach((dataIndex, i) => {
                    const data = currentChartData.resampledData[dataIndex];
                    markLineData.push({
                        xAxis: data.date,
                        label: {
                            show: true,
                            position: 'start',
                            formatter: () => data.date.includes('~') ? data.date.replace(' ~ ', '\n') : data.date,
                            color: '#fff',
                            backgroundColor: '#333',
                            padding: [4, 8],
                            borderRadius: 4,
                        }
                    });
                    dotData.push({
                        value: [data.date, data.close],
                        label: {
                            position: i % 2 === 0 ? 'top' : 'bottom'
                        }
                    });
                });

                if (multiCrosshairPoints.length > 1) {
                    let lastLabelPosition = null;
                    for (let i = 1; i < multiCrosshairPoints.length; i++) {
                        const prevIndex = multiCrosshairPoints[i - 1];
                        const currentIndex = multiCrosshairPoints[i];
                        const prevData = currentChartData.resampledData[prevIndex];
                        const currentData = currentChartData.resampledData[currentIndex];

                        const priceDiff = currentData.close - prevData.close;
                        const percentDiff = (priceDiff / prevData.close) * 100;
                        const color = priceDiff >= 0 ? '#eb5454' : '#47b262';
                        const sign = priceDiff >= 0 ? '+' : '';

                        const labelText = `${sign}${priceDiff.toFixed(2)}\n(${sign}${percentDiff.toFixed(2)}%)`;

                        // Start with MACD-like logic: 'bottom' for up, 'top' for down
                        let labelPosition = priceDiff >= 0 ? 'bottom' : 'top';

                        // If the position is the same as the last one, flip it to avoid overlap
                        if (labelPosition === lastLabelPosition) {
                            labelPosition = labelPosition === 'top' ? 'bottom' : 'top';
                        }

                        markAreaData.push([
                            {
                                xAxis: prevData.date,
                                itemStyle: {
                                    color: 'rgba(0,0,0,0)' // Transparent area
                                },
                                label: {
                                    show: true,
                                    formatter: labelText,
                                    color: color,
                                    fontSize: 12,
                                    fontWeight: 'bold',
                                    position: 'top',
                                    distance: -30
                                }
                            },
                            {
                                xAxis: currentData.date
                            }
                        ]);
                        lastLabelPosition = labelPosition;
                    }
                }

                const gridCount = myChart.getOption().grid.length;
                for (let i = 0; i < gridCount; i++) {
                    seriesUpdate.push({
                        name: `multi-crosshair-${i}`,
                        markLine: { data: markLineData },
                        markArea: i === 0 ? { data: markAreaData } : { data: [] }
                    });
                }

                seriesUpdate.push({
                    name: 'multiCrosshairDots',
                    data: dotData
                });

                myChart.setOption({ series: seriesUpdate });
            }

            const clearCrosshairBtn = document.getElementById('clearCrosshairBtn');
            clearCrosshairBtn.addEventListener('click', function () {
                // æ¸…ç©ºå–®é»åå­—ç·š
                lastClickedIndex = null;
                let seriesUpdate = [];
                const gridCount = myChart.getOption().grid.length;
                for (let i = 0; i < gridCount; i++) {
                    seriesUpdate.push({
                        name: `crosshair-${i}`,
                        markLine: { data: [] }
                    });
                }
                myChart.setOption({ series: seriesUpdate });
                updateTitles(currentChartData.resampledData.length - 1);

                // åŒæ™‚æ¸…ç©ºå¤šé»æ¨™è¨˜
                multiCrosshairPoints = [];
                renderMultiCrosshairs();
            });

            const multiCrosshairToggle = document.getElementById('multiCrosshairToggle');

            multiCrosshairToggle.addEventListener('change', function () {
                isMultiCrosshairMode = this.checked;

                // åˆ‡æ›æ¨¡å¼æ™‚æ¸…ç©ºæ‰€æœ‰æ¨™è¨˜
                clearCrosshairBtn.click();
            });

            let resizeTimeout;
            window.addEventListener('resize', function () {
                myChart.resize();

                // ä½¿ç”¨ debounce é¿å…é »ç¹è§¸ç™¼é‡å»º
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function () {
                    // è¢å¹•æ—‹è½‰æˆ–å°ºå¯¸è®ŠåŒ–æ™‚ï¼Œé‡æ–°å»ºæ§‹æ•´å€‹åœ–è¡¨ä½ˆå±€
                    if (currentChartData && currentChartData.resampledData) {
                        updateChart(currentPeriod);
                    }
                }, 150);
            });
        }

        initApp();
    </script>

</body>

</html>
